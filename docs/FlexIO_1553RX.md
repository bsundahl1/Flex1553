FlexIO 1553 Receive class
==========================

This class implements a 1553 receiver in one FlexIO module of the NXP
i.MXRT1062 processor. This is a physical layer only, it does not know the
meaning of a packet, or any of the control bits other than parity. There is
no synchronization with the transmit module.

## Background
MIL-STD-1553 is a serial communication protocol developed for the military
in the late 1970's, and is still used today in many military vehicles and
aircraft. It has also found its way into some industrial applications. It is
very reliable and fairly fast with a 1Mb/s bit rate. You could consider it
a predecessor to CAN bus.

On the down side, it is a fairly difficult standard to implement at the
physical layer and is generally done with custom peripheral IC's, or in
recent years, with an FPGA. FlexIO gives us a new tool to use for custom or
uncommon protocols. This might not be a military grade solution, but it is
good enough to provide basic communicate with 1553 devices, at least for
test purposes.

### RX Pins

Each receive channel requires one FlexIO module. These are the pins which
may be used for the data receive line:

     Teensy 4.1
      FlexIO_1          FlexIO_2         FlexIO_3
       2,3,4,5,33        6,9,11,13        14,15,16,17,20,21,22,23,40,41

This is configured by the receiver class constructor, FlexIO_1553RX().


## Hardware restrictions

There can only be one Flex1553RX or TX instantiation for each FlexIO
module. In the case of the i.MXRT1062, there are three FlexIO modules, and
you would typically implement one TX class and one or two RX classes. You
can not have two instances pointing to the same FlexIO module.


## FlexIO Configuration Overview
This is a fairly complex configuration and uses many of the capabilities of
FlexIO. This circuit can be broken down into four basic sections:

 **Sync Detection** continuously scans the incoming data stream for a valid
 1553 sync pattern, and when found, triggers the rest hardware to
 demodulate and capture the data bits.

 **Demodulation** decodes the Manchester II bi-phase signal pattern used by
 1553 into two output signals, one for the decoded data, and the other to
 indicate any bit faults found in the input.

 **Data capture** just grabs the output from the state machine and triggers
 an interrupt so that software can retrieve the data.

 **End of Transmission** triggers an interrupt after a packet has been
 received, allowing software to respond with an and acknowledge packet
 within the timing window allowed by the 1553 spec.

 Each of these is described in detail below.


### Sync Detection

1553 uses an encoding technique which causes a toggle in the signal pattern
at least once per microsecond, while data is being sent. The exception to
this are the two sync patterns. The COMMAND SYNC goes high for 1.5
microseconds, and then low for 1.5 microseconds at the start of the
transmission. The DATA SYNC goes the other way around: low first, then
high, for 1.5 microseconds each.

One of the features of FlexIO is the "Match Continuous Mode" of the shifters
which allows us to look for this type of pattern. I had a difficult time
fitting this design into the eight shifters of FlexIO, so I am only able to
watch for one of the two sync patterns. Fortunately (probably not coincidence)
the COMMAND SYNC always comes first. So we will watch for that one.

Initially, the sync shifter is the only thing running in this circuit
besides some clocks. When the sync pattern is found, we trigger the rest of
the FlexIO circuit to start decoding the signal, and at the same time, we
trigger an interrupt which allows software to change the sync pattern to
the DATA SYNC, which is expected on all of the rest of the words in the
transmission.

In this circuit, Shifter3 is the sync detector and it is clocked a 5MHz.
The sync pattern is 3 microseconds long (1.5 + 1.5), so 3us * 5MHz = 15
bits will be sampled by the shifter every 3us. To allow for a little
error in our sampling, we will only use 14 bits for the comparison, and
will check for a pattern of 7 high bits and 7 low bits.

Though the shifter is physically 32 bits, Match Continuous mode only allows
us to use 16 bits. This is because it is using the associated holding
register for 16-bits of pattern and 16-bits of mask bits. This is what
allows us to look at only 14 of the 16 total bits.

In theory, the trigger should occur at the closest rising clock edge to the
end of the sync pattern. Using a 5MHz clock (200ns period) we should
trigger within a +/-100ns window, which should be sufficient. If necessary,
we could increase this clock speed to 6MHz (166ns period) and use all 16-
bits of the shifter for the sync comparison. This should narrow our trigger
window to +/-83ns. I have not tried this yet.

The 5MHz clock for Shifter3 is being generated by Timer5, and you would
think that that is all we would need. But there seems to be a bug in the
match continuous mode (or maybe I am not using it as intended) which causes
the shifter to reset, thus zeroing the 16-bits that it happened to contain
at that time, and possibly missing the sync pattern. The reset occurs every
time that the controlling timer wraps around, so in the case of Timer5,
this would be on every clock! **So the shifter would ALWAYS contain
zeros!**

Timer3 and 4 are the workaround for this issue. Timer3 is used as the
controlling timer. The 5MHz shift clock is just passed through, using the
"Shift on trigger" feature, but it is now the Timer3 wrap around that will
reset Shifter3. We are not really using Timer3 to time anything, so we
could set this as high as 32767 clocks, but eventually it would wrap, and
potentially miss a sync pattern.

Timer 4 is used to reset the count in Timer3 back to the initial count
(timers only count down), so that it does not timeout, and thus does not
reset the shifter. The timer values dont really matter, as long as Timer4
toggles faster than Timer3, so that Timer3 never reaches zero.


### Demodulation

In normal use, 1553 uses transformer coupling, and this requires that the
data lines be continuously changing. If it were to stay in one state for
any length of time, the transformer would saturate and would no longer be
able hold the logic level. 1553 uses Manchester II encoding to avoid this
issue. Manchester encoding is a scheme where the logic state is determined
by a transition (toggle) rather than the voltage level. A change from low
to high represents a logic 0, and high to low is a logic 1.

One bit time is always 1 microsecond, and a transition always occurs at the
center of the bit time. So to transmit a series of zeros for example, the
data line would need to go low at the start of the bit time, so that it can
transition high at the center (0.5us later) to signal a logic 0, then go
back to low at the start of the next bit time (0.5us later) to prepare to
send the next logic 0. My point is that in the way that we normally think
about computer logic levels, two logic level are required to define a
single logic state using this encoding. We will need to shift bits on a
2MHz clock to support a 1Mbit data rate.

The most obvious way to do this is to use software to turn each logic state
into two levels, and to double the number of bits we will transmit. Every
single data bit would have to be calculated and shifted into place, and we
would be transferring twice as much data to the hardware. Ugly, but it
should work.

FlexIO gives us a better way. Using the state machine feature of FlexIO, we
can make this look more like a normal peripheral, writing the data we want
to send, and let FlexIO produce the actual output levels.

You might think of a state machine as a very very simple version of a
microprocessor, only simpler. It has a fixed number of states that it can
be in (FlexIO is limited to 8 states), and it can change from one state to
another based on its inputs, its current state, and a lookup table. FlexIO
implements a Moore state machine, which means that its outputs depend only
on the current state. That is really all there is to it.

### Data capture

The data capture works very similar to any other FlexIO data capture, the
biggest difference being that it is fed by the output of the state machine
demodulator instead of directly from an input pin.

### End of Transmission (EOT)

One issue that software is going to have to deal with is sending the
acknowledge (STATUS WORD) after a packet has been received. The 1553 spec
allows a window of 4 to 12us for this response, with a timeout (an error
condition) of 14us.

The EOT circuit in the FlexIO is a timer which is set to timeout 4us after
receiving a word, but is reset by each new word received (each new sync
pattern). So the timeout will not occur until 4us after the transmission
ends. This timer will trigger an interrupt so that software can handle the
acknowledge.

### Interrupts

The following interrupts may be used to trigger software routines from a
FlexIO receiver event.

#### Shifter1 Interrupt: Receiver full

This interrupt will occur after a full word is received, when FlexIO loads
the word from Shifter1 into the shifter holding register. Software must
retrieve this word from the holding register before the next word is
received, to avoid an overrun. This interrupt is cleared by reading
Shifter1

//#### Shifter3 Interrupt: Sync Pattern Found (non-latching)
#### Timer7 Interrupt: Sync Pattern Found

This interrupt will occur when the currently selected sync pattern is
detected. This may be used to change the sync pattern between received
words. This is a latched version of the Shifter3 status flag.
This interrupt must be cleared by writing a 1 to bit 7 of the FlexIO
TIMSTAT register. Or call clearInterrupt(FLEX1553RX_SYNC_FOUND_INTERRUPT).

#### Timer2 Interrupt: End of Receive

Once we start receiving data, a new SYNC pattern should be seen every 20
microseconds, until the end of the data. This interrupt will occur 21
microseconds after the last SYNC, if no new SYNC is detected. This could be
used to turn off the receiver at the end of data, even if the data ends
sooner than expected.
This interrupt must be cleared by writing a 1 to bit 2 of the FlexIO
TIMSTAT register. Or call clearInterrupt(FLEX1553RX_END_OF_RECEIVE_INTERRUPT).

