FlexIO 1553 Receive class
==========================
## Background
MIL-STD-1553 is a serial communication protocol developed for the military
in the late 1970's, and is still used today in many military vehicles and
aircraft. It has also found its way into some industrial applications. It is
very reliable and fairly fast with a 1Mb/s bit rate. You could consider it
a predecessor to CAN bus.

On the down side, it is a fairly difficult standard to implement at the
physical layer and is generally must be done with custom peripheral IC's,
or in recent years, with an FPGA. FlexIO gives us a new tool to use for
custom or uncommon protocols. This might not be a military grade solution,
but it is good enough to communicate with 1553 devices, at least for test
purposes.


## FlexIO Configuration
This is a fairly complex configuration and uses many of the capabilities of
FlexIO. This circuit can be broken down into three basic sections:

 **Sync Detection** continuously scans the incoming data stream for a valid
 1553 sync pattern, and when found, triggers the rest hardware to
 demodulate and capture the data bits.

 **Demodulation** decodes the Manchester II bi-phase signal pattern used by
 1553 into two output signals, one for the decoded data, and the other to
 indicate any bit faults found in the input.

 **Data capture** just grabs the output from the state machine and triggers
 and interrupt so that software can retrieve the data.

 Each of these is described in detail below.

### Sync Detection

1553 uses an encoding technique which causes a toggle in the signal pattern
at least once per microsecond, while data is being sent. The exception to
this are the two sync patterns. The COMMAND SYNC goes high for 1.5
microseconds, and then low for 1.5 microseconds at the start of the
transmission. The DATA SYNC goes the other way around: low first, then
high, for 1.5 microseconds each.

One of the features of FlexIO is the "Match Continuous Mode" of the shifters
which allows us to look for this type of pattern. I had a difficult time
fitting this design into the eight shifters of FlexIO, so I am only able to
watch for one of the two sync patterns. Fortunately (probably not coincidence)
the COMMAND SYNC always comes first. So we will watch for that one.

Initially, the sync shifter is the only thing running in this circuit
besides some clocks. When the sync pattern is found, we trigger the rest of
the FlexIO circuit to start decoding the signal, and at the same time, we
trigger an interrupt which allows software to change the sync pattern to
the DATA SYNC, which is expected on all of the rest of the words in the
transmission.

In this circuit, Shifter3 is the sync detector and it is clocked a 5MHz.
The sync pattern is 3 microseconds long (1.5 + 1.5), so 3us * 5MHz = 15
bits will be sampled by the shifter every 3us. To allow for a little
error in our sampling, we will only use 14 bits for the comparison, and
will check for a pattern of 7 high bits and 7 low bits.

Though the shifter is physically 32 bits, Match Continuous mode only allows
us to use 16 bits. This is because it is using the associated holding
register for 16-bits of pattern and 16-bits of mask bits. This is what
allows us to look at only 14 of the 16 total bits.

In theory, the trigger should occur at the closest rising clock edge to the
end of the sync pattern. Using a 5MHz clock (200ns period) we should
trigger within a +/-100ns window, which should be sufficient. If necessary,
we could increase this clock speed to 6MHz (166ns period) and use all 16-
bits of the shifter for the sync comparison. This should narrow our trigger
window to +/-83ns. I have not tried this yet.

The 5MHz clock for Shifter3 is being generated by Timer5, and you would
think that that is all we would need. But there seems to be a bug in the
match continuous mode (or maybe I am not using it as intended) which causes
the shifter to reset, thus zeroing the 16-bits that it happened to contain
at that time, and possibly missing the sync pattern. The reset occurs every
time that the controlling timer wraps around, so in the case of Timer5,
this would be on every clock! **So the shifter would ALWAYS contain
zeros!**

Timer3 and 4 are the workaround for this issue. Timer3 is used as the
controlling timer. The 5MHz shift clock is just passed through, using the
"Shift on trigger" feature, but it is now the Timer3 wrap around that will
reset Shifter3. We are not really using Timer3 to time anything, so we
could set this as high as 32767 clocks, but eventually it would wrap, and
potentially miss a sync pattern.

Timer 4 is used to reset the count in Timer3 back to the initial count
(timers only count down), so that it does not timeout, and thus does not
reset the shifter. The timer values dont really matter, as long as Timer4
toggles faster than Timer3, so that Timer3 never reaches zero.



### Demodulation


### Data capture
