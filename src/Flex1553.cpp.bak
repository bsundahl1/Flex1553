#include <Arduino.h>
#include <Flex1553.h>

// 7/12/21  change to a 48MHz clock so we can derive 6MHz from timers
// 9/10/21  reconfigured code to use C++ class instead of standard C
// 9/20/21  created base class for reusable FlexIO functions

// Bug list
//   startup messages not printing
//   FLEX01 pair2 always seems to be enabled
//   need to finish config_io_pins

// Optional build flags:
#define FLEX_PRINT_MESSAGES   // uncomment to print startup messages to serial port
#define FLEX_DEBUG            // uncomment to bring out debug pins
//#define FLEX02_DEBUG  // uncomment to bring out debug pins
#define FLEX03_DEBUG  // uncomment to bring out debug pins
//#define FLEX01_TX_CHB // enable transmit on both A and B channels
   // if not defined, only channel A output pins will be used


/***************************************************************************************
*    Start of 1553 TX Class
***************************************************************************************/

// assign flex data line resources to outputs. some of the are used internally
// others are just brought out for debug. Note that flex FXIO_D[7:0] are reserved
// for the state machine outputs.
#define FLEX1_1553TX_PIN_SHFT1_OUT 10    // routes shifter to state machine  (not accessable on teensy pin)
#define FLEX1_1553TX_PIN_SHFT2_OUT 11    // routes shifter to state machine  (not accessable on teensy pin)
#define FLEX1_1553TX_PIN_TIM0_OUT  8     // for debug only
#define FLEX1_1553TX_PIN_TIM2_OUT  12    // for debug only
#define FLEX1_1553TX_PIN_TIM3_OUT  14    // 1MHz clock routed between timers
#define FLEX1_1553TX_PIN_TIM5_OUT  15    // for debug only
#define FLEX1_1553TX_PIN_TIM7_OUT  13    // for debug only

#define FLEX2_1553TX_PIN_SHFT1_OUT 10    // routes shifter to state machine
#define FLEX2_1553TX_PIN_SHFT2_OUT 11    // routes shifter to state machine
#define FLEX2_1553TX_PIN_TIM0_OUT  28    // for debug only
#define FLEX2_1553TX_PIN_TIM2_OUT  12    // for debug only
#define FLEX2_1553TX_PIN_TIM3_OUT  16    // 1MHz clock routed between timers
#define FLEX2_1553TX_PIN_TIM5_OUT  17    // for debug only
#define FLEX2_1553TX_PIN_TIM7_OUT  18    // for debug only

#define FLEX3_1553TX_PIN_SHFT1_OUT 10    // routes shifter to state machine
#define FLEX3_1553TX_PIN_SHFT2_OUT 11    // routes shifter to state machine
#define FLEX3_1553TX_PIN_TIM0_OUT  8     // for debug only
#define FLEX3_1553TX_PIN_TIM2_OUT  12    // for debug only
#define FLEX3_1553TX_PIN_TIM3_OUT  13    // 1MHz clock routed between timers
#define FLEX3_1553TX_PIN_TIM5_OUT  14    // for debug only
#define FLEX3_1553TX_PIN_TIM7_OUT  15    // for debug only

// manually sellect which set to use
#define FLEX_1553TX_PIN_SHFT1_OUT    FLEX2_1553TX_PIN_SHFT1_OUT
#define FLEX_1553TX_PIN_SHFT2_OUT    FLEX2_1553TX_PIN_SHFT2_OUT
#define FLEX_1553TX_PIN_TIM0_OUT     FLEX2_1553TX_PIN_TIM0_OUT
#define FLEX_1553TX_PIN_TIM2_OUT     FLEX2_1553TX_PIN_TIM2_OUT
#define FLEX_1553TX_PIN_TIM3_OUT     FLEX2_1553TX_PIN_TIM3_OUT
#define FLEX_1553TX_PIN_TIM5_OUT     FLEX2_1553TX_PIN_TIM5_OUT
#define FLEX_1553TX_PIN_TIM7_OUT     FLEX2_1553TX_PIN_TIM7_OUT




// Class constructor
FlexIO_1553TX::FlexIO_1553TX(uint8_t flex_num, bool pair1, bool pair2, bool pair3, bool pair4)
   :FlexIO_Base(flex_num, 48.0)
{
   // initialize pin pair structures
   for( int i=0; i<4; i++ ) {
      m_pair[i].enabled  = false;
      m_pair[i].f_posPin =  i * 2;     // flex pin number are in order from 0 to 7
      m_pair[i].f_negPin = (i * 2) + 1;
      m_pair[i].t_posPin = getTeensyPin(  i * 2 );    // teensy pin numbers
      m_pair[i].t_negPin = getTeensyPin( (i * 2) + 1 );
   }

   m_pair[0].allowed = pair1;
   m_pair[1].allowed = pair2;
   m_pair[2].allowed = pair3;
   m_pair[3].allowed = pair4;
   m_altFlex  = (m_flex_num == 3)? 9 : 4; // FlexIO3 uses ALT9, FLEXIO1 & 2 use ALT4
   m_altGpio  = 5;  // gpio always uses Alt5
   //m_baud_div = 30; // divide from 30MHz to 1MHz
   m_chan = -1;
   m_just_configured = false;
}


bool FlexIO_1553TX::begin( void )
{
   #ifdef FLEX_PRINT_MESSAGES
      if(m_flex_num == 0)
         Serial.println( "Error: invalid flexIO module number" );
      else {
         Serial.print( "Configuring 1553TX on FlexIO" );
         Serial.print( m_flex_num );
         Serial.println();
      }
   #endif

   if( FlexIO_Base::begin() == false ) { // configures pll divider
   #ifdef FLEX_PRINT_MESSAGES
      Serial.println( "Error: FlexIO_Base::begin() failed" );
   #endif
      return false;
   }

   if( config_flex() ==  false ) {
   #ifdef FLEX_PRINT_MESSAGES
      Serial.println( "Error: config_flex() failed" );
   #endif
      return false;
   }

   if( config_io_pins() == false ) {
   #ifdef FLEX_PRINT_MESSAGES
      Serial.println( "Error: config_io_pins() failed" );
   #endif
      return false;
   }

   #ifdef FLEX_PRINT_MESSAGES  // print out pin pairs used
      for( int i=0; i<4; i++ ) {
         if(m_pair[i].allowed == true) {
            Serial.print( "  Pin pair " );
            Serial.print( i+1 );  // index 0 is pair 1
            Serial.print( ": FXIO_D[" );
            Serial.print( m_pair[i].f_posPin );
            Serial.print( ":" );
            Serial.print( m_pair[i].f_negPin );
            Serial.print( "] = Teensy pins " );
            Serial.print( m_pair[i].t_posPin );
            Serial.print( ", " );
            Serial.print( m_pair[i].t_negPin );
            Serial.println();
         }
      }

      // print out the internal FXIO connections used
      int pin = -1;
      for( int i=0; i<7; i++ ) {
         switch(i) {
            case 0:
               Serial.print( "  SHFT1_OUT = FXIO_D" );
               pin = FLEX_1553TX_PIN_SHFT1_OUT;
               break;
            case 1:
               Serial.print( "  SHFT2_OUT = FXIO_D" );
               pin = FLEX_1553TX_PIN_SHFT2_OUT;
               break;
            case 2:
               Serial.print( "  TIM0_OUT  = FXIO_D" );
               pin = FLEX_1553TX_PIN_TIM0_OUT;
               break;
            case 3:
               Serial.print( "  TIM2_OUT  = FXIO_D" );
               pin = FLEX_1553TX_PIN_TIM2_OUT;
               break;
            case 4:
               Serial.print( "  TIM3_OUT  = FXIO_D" );
               pin = FLEX_1553TX_PIN_TIM3_OUT;
               break;
            case 5:
               Serial.print( "  TIM5_OUT  = FXIO_D" );
               pin = FLEX_1553TX_PIN_TIM5_OUT;
               break;
            case 6:
               Serial.print( "  TIM7_OUT  = FXIO_D" );
               pin = FLEX_1553TX_PIN_TIM7_OUT;
               break;
         }
         Serial.print( pin );

         // print the associated Teensy pin if it is being used for DEBUG
         #ifdef FLEX_DEBUG
             Serial.print( " = Teensy pin " );
             Serial.print( getTeensyPin(pin) );
         #endif
         Serial.println();
      }
   #endif

   return true;
}



bool FlexIO_1553TX::config_io_pins(void)
{
   // setup pin mux to route FlexIO to Teensy pins
   // this is the primary output from the 1553 module
   for( int i=0; i<4; i++ ) {
      if(m_pair[i].allowed == true) {
         // For each output pin, set the GPIO pins low, but then set
         // the MUX to FlexIO. We can then disable this channel by changing
         // the MUX back to GPIO
         digitalWrite(m_pair[i].t_posPin, false);  // set the GPIO pins low
         digitalWrite(m_pair[i].t_negPin, false);
         pinMode(m_pair[i].t_posPin, OUTPUT);      // and configure as outputs
         pinMode(m_pair[i].t_negPin, OUTPUT);
         setPinMux(m_pair[i].t_posPin);            // and set the PinMux to FlexIO
         setPinMux(m_pair[i].t_negPin);
      }
   }

   // The rest of this code routs optional outputs to IO pins, primarily for debug.
   // You will normally want to turn this off so that you can use these IO pins
   // for other purposes. Note that the defines refer to FlexIO data lines (FXIO_Dxx),
   // and are translated to Teensy pins.
   #ifdef FLEX_DEBUG
      setPinMux( getTeensyPin(FLEX_1553TX_PIN_SHFT1_OUT) );
      setPinMux( getTeensyPin(FLEX_1553TX_PIN_SHFT2_OUT) );
      setPinMux( getTeensyPin(FLEX_1553TX_PIN_TIM0_OUT)  );
      setPinMux( getTeensyPin(FLEX_1553TX_PIN_TIM2_OUT)  );
      setPinMux( getTeensyPin(FLEX_1553TX_PIN_TIM3_OUT)  );
      setPinMux( getTeensyPin(FLEX_1553TX_PIN_TIM5_OUT)  );
      setPinMux( getTeensyPin(FLEX_1553TX_PIN_TIM7_OUT)  );
   #endif


//   digitalWrite(4, false);  // set the GPIO pins low
//   digitalWrite(5, false);  // but then set the MUX to FlexIO
//   pinMode(4, OUTPUT);      // we can then disable this channel
//   pinMode(5, OUTPUT);      // by changing the MUX back to GPIO
//   IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04 = 4;     // FLEXIO pin4    Teensy pin 2
//   IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05 = 4;     // FLEXIO pin5    Teensy pin 3
//   //channel_config = FLEX1553_CH_A;
//#ifdef FLEX01_TX_CHB // enable transimit on both A and B channels
//    // final output from state machine, channel B
//   digitalWrite(6, false);
//   digitalWrite(7, false);
//   pinMode(6, OUTPUT);
//   pinMode(7, OUTPUT);
//   IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06 = 4;     // FLEXIO pin6    Teensy pin 4
//   IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07 = 4;     // FLEXIO pin7    Teensy pin 33
//   //channel_config = FLEX1553_CH_BOTH;
//#endif
//#ifdef FLEX01_DEBUG
//    // inputs to state machine
//   //IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10 = 4;      // FLEXIO pin10   Teensy pin n/a
//   //IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11 = 4;      // FLEXIO pin11   Teensy pin n/a
//   IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 4;     // FLEXIO pin12   Teensy pin 52
//     // Timer0 2MHz state machine clock
//   IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08 = 4;     // FLEXIO pin8    Teensy pin 5
//     // Data reg empty flag
//   IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 4;     // FLEXIO pin13   Teensy pin 49
//     // Timer1 1MHz data clock
//   IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 4;     // FLEXIO pin14   Teensy pin 50
//#endif
   return(true);
}



// Configures FlexIO as a 1553 transmitter
// @return   returns false on error
bool FlexIO_1553TX::config_flex( void )
{
   // pins used by this module
 //  #define FLEX1_1553_PIN_TIM0_OUT  8     // for debug only
   //#define FLEX1_1553_PIN_TIM1_OUT  14    // for debug only
      // the following 3 pins must stay sequential, they are used as
      // inputs to the state machine
 //  #define FLEX1_1553_PIN_SHFT1_OUT 10    // routes shifter to state machine
 //  #define FLEX1_1553_PIN_SHFT2_OUT 11    // routes shifter to state machine
 //  #define FLEX1_1553_PIN_TIM2_OUT  12    // for debug only
 //  #define FLEX1_1553_PIN_TIM3_OUT  14    // 1MHz clock routed between timers
   //#define FLEX1_1553_PIN_TIM4_OUT  14    // for debug only
 //  #define FLEX1_1553_PIN_TIM5_OUT  15    // for debug only
 //  #define FLEX1_1553_PIN_TIM7_OUT  13    // for debug only
   // four more pins are used for the state machine output
   // but they are pre-assigned to FlexIO[7:4] and configured
   // in a different way

   // Check that the Flex clock is enabled
   // The flex clock should already be configured at this point.
   // The Flex clock MUST BE CONFIGURED before accessing any Flex register
   // or else the code will hang.
   if( !clock_running() )
      return(false);  // abort

   // if the Flex module gets hung up, reconfiguring will not fix it, you will
   // need to reset it. Flex module should be disabled during configuration or
   // else you will likely get "random" output transitions during config.
   // Reset and disable FLEXIO (clock MUST be enabled or this will hang)
   m_flex->CTRL |= 2;    // reset Flex module
   m_flex->CTRL &= 0xfffffffc;  // release reset and leave Flex disabled



   // State Machine **************************************************
   // This uses five shifters as a five-state state machine to produce Manchester II
   // biphase encoded data bits
   //  state 0 = outputs disabled
   //  state 4 = first  half of a "1" state
   //  state 6 = second half of a "1" state
   //  state 7 = first  half of a "0" state
   //  state 5 = second half of a "0" state
   // all 5 shifters are set the same, only the state tables are different

   // setup state 0
   m_flex->SHIFTCTL[0]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           //FLEXIO_SHIFTCTL_TIMPOL       |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( FLEX_1553TX_PIN_SHFT1_OUT )   |
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

   m_flex->SHIFTCFG[0]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // enable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  0 )    |        // enable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs

  // setup state 4
   m_flex->SHIFTCTL[4]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           //FLEXIO_SHIFTCTL_TIMPOL       |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( FLEX_1553TX_PIN_SHFT1_OUT )   |
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

   m_flex->SHIFTCFG[4]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // enable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  0 )    |        // enable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs
                                                   //    Teensy pins 2, 3, 4, 33

   // setup state 5
   m_flex->SHIFTCTL[5]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           //FLEXIO_SHIFTCTL_TIMPOL       |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( FLEX_1553TX_PIN_SHFT1_OUT )   |
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

  m_flex->SHIFTCFG[5]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // enable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  0 )    |        // enable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs
                                                   //    Teensy pins 2, 3, 4, 33

   // setup state 6
   m_flex->SHIFTCTL[6]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           //FLEXIO_SHIFTCTL_TIMPOL       |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( FLEX_1553TX_PIN_SHFT1_OUT )   |
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

   m_flex->SHIFTCFG[6]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // enable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  0 )    |        // enable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs
                                                   //    Teensy pins 2, 3, 4, 33

   // setup state 7
   m_flex->SHIFTCTL[7]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           //FLEXIO_SHIFTCTL_TIMPOL       |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( FLEX_1553TX_PIN_SHFT1_OUT )   |
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

   m_flex->SHIFTCFG[7]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // enable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  0 )    |        // enable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs
                                                   //    Teensy pins 2, 3, 4, 33
   // Two output bits from the state machine (a pin pair), are used to pulse
   // two FETs to drive an isolation transformer. The outputs are differential,
   // causing a reversal of the current in the transformer primary for each bit.
   // At the end of the transmission, the state machine goes to the "0" idle
   // state which turns off both transistors.

   // load state lookup table               output  : next state
   m_flex->SHIFTBUF[0] =  0x009E7000U;  //  0000 0000 : 100 111 100 111 000 000 000 000b
   m_flex->SHIFTBUF[4] =  0x51DADDADU;  //  0101 0101 : 110 110 101 101 110 110 101 101b
   m_flex->SHIFTBUF[7] =  0xA2B76B76U;  //  1010 1010 : 101 101 110 110 101 101 110 110b
   m_flex->SHIFTBUF[5] =  0x519E7000U;  //  0101 0101 : 100 111 100 111 000 000 000 000b
   m_flex->SHIFTBUF[6] =  0xA29E7000U;  //  1010 1010 : 100 111 100 111 000 000 000 000b

   // setup data shifter 1 **************************************************
   // this is the data shifter. writing data to SHIFTBUF1 will trigger the transmit
   // 21 bits are used. The first 3 (LSB) for the Sync, 16 bits of data, one parity,
   // and the last bit (MSB) is used to turn off the transmitter
   m_flex->SHIFTCTL[1]  =
           FLEXIO_SHIFTCTL_TIMSEL( 1 )    |        // controlled from timer 1
           // FLEXIO_SHIFTCTL_TIMPOL      |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // pin output enabled
           FLEXIO_SHIFTCTL_PINSEL( FLEX_1553TX_PIN_SHFT1_OUT )   |        // FLEXIO pin 10    Teensy pin n/a
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 2 );              // transmit mode

   m_flex->SHIFTCFG[1]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled

   // setup data shifter 2 **************************************************
   // This shfiter is used for control bits, which will modify the data
   // Both shifters shift data out at the same time
   // A zero in this shifter causes the same bit postion in the data shifter
   // to be output without transition. A one will cause the data bit to
   // transition: 0 = 0 to 1, 1 = 1 to 0
   m_flex->SHIFTCTL[2]  =
           FLEXIO_SHIFTCTL_TIMSEL( 1 )    |        // controlled from timer 1
           // FLEXIO_SHIFTCTL_TIMPOL      |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // pin output enabled
           FLEXIO_SHIFTCTL_PINSEL( FLEX_1553TX_PIN_SHFT2_OUT )   |        // FLEXIO pin 11    Teensy pin n/a
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 2 );              // transmit mode

   m_flex->SHIFTCFG[2]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled

   // the control bits are always the same. remember LSB first
   // the shifter will reload the same data each time TIMER1 is triggered
   m_flex->SHIFTBUF[2] =  0x0ffffaU;  //   1111 1111 1111 1111 1010b;
   //m_flex->SHIFTBUF[2] =  0x0000000U;   // for debug: SM should output raw data from shifter 1

   // setup flex timer 0 *****************************************************
   // this is a 2MHz clock to step the state machine
   // it is clocked from from the FLEXIO clock
   // it is always running
   m_flex->TIMCTL[0]    =
           FLEXIO_TIMCTL_TRGSEL( 5 )      |        // not used
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active low
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( FLEX_1553TX_PIN_TIM0_OUT )     |        // timer pin 13, Teensy pin 49 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit mode

   m_flex->TIMCFG[0]    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )       ;       // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


   //   divide clock by 24               (baudrate_divider/2-1))
   //                                         (24/2-1)
   //                                            (11)
   m_flex->TIMCMP[0]  = 11;

   // setup flex timer 1 *****************************************************
   // this is a counter to track the bit count for both shifters
   // it is clocked from Timer3 (1MHz)
   // it is enabled by Shifter 1 status flag via Timer4 and Timer5
   m_flex->TIMCTL[1]    =
           FLEXIO_TIMCTL_TRGSEL( 19 )     |        // Timer4 out (N * 4) + 3
           //FLEXIO_TIMCTL_TRGSEL( 23 )     |        // Timer5 out (N * 4) + 3
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 0 )      |        // timer pin output disabled
           FLEXIO_TIMCTL_PINSEL( FLEX_1553TX_PIN_TIM3_OUT )   |   // used as the clock input
           FLEXIO_TIMCTL_PINPOL        |           // timer pin active low
           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

   m_flex->TIMCFG[1]    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 2 )      |        // decrement on pin input, shift clock = pin input
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
           FLEXIO_TIMCFG_TIMENA( 2 )      |        // enable timer on (inverted) trigger high
                  // this is needed to prevent a timing synchronization fault that
                  // occurs occasionally if the trigger occurs too close to the clock edge
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

   //  We are shifting 20 bits of data
   //  20 shifts,  divide clock by 1      ((n*2-1)<<8) | (baudrate_divider/2-1))
   //                                     (20*2-1)<<8  | (1/2-1)
   //                                         (39)<<8  | (0)
   //                                          0x2700  | 0x0
   m_flex->TIMCMP[1]    =    0x2700;

   // setup flex timer 2 *****************************************************
   // This produced the Enable input to the state machine which
   // will disable the output at the end of the transmission.
   // This timer produces a .525us delay, which is reset after
   // each edge of Timer1 output (500us edges). Thus, the timer
   // output will stay high until .525us after Timer1 stops.
   // clocked from flex clock
   // enabled by Timer1 enable
   // reset by Timer 1 output
   // disabled by compare (timeout)
   m_flex->TIMCTL[2]    =
           FLEXIO_TIMCTL_TRGSEL( 7 )      |        // triggered by Timer 1 output =(1 * 4) + 3
           FLEXIO_TIMCTL_TRGPOL           |        // trigger active low
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( FLEX_1553TX_PIN_TIM2_OUT )     |        // timer pin 12 (wired to state machine)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer

   m_flex->TIMCFG[2]    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // Decrement on Flex clock
           FLEXIO_TIMCFG_TIMRST( 7 )      |        // reset on trigger, both edges
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // Timer disabled on timer compare
           FLEXIO_TIMCFG_TIMENA( 1 )      |        // Timer enabled on Timer N-1 enable
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

   // divide Flex clock by 48 to get 0.50us
   //                         (baudrate_divider/2-1))
   //                         (48/2-1)
   //                         (23)
   // time = (25 + 1)/48  = .542us
   m_flex->TIMCMP[2]    =    25;


   // setup flex timer 3 *****************************************************
   // 1MHz clock for the shifters
   // This is free running and is always running
   // it is clocked from from the Flex clock
   // and is synchronized to Timer0 on the rising edge, simply because
   // both clocks are started at the same time (at the end of config)
   m_flex->TIMCTL[3]    =
           FLEXIO_TIMCTL_TRGSEL( 3 )      |        // Triggered by Timer0 =(0 * 4) + 3
           FLEXIO_TIMCTL_TRGPOL           |        // trigger active low
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( FLEX_1553TX_PIN_TIM3_OUT )     |        // timer pin 19 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit mode

   m_flex->TIMCFG[3]    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on flex clock
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )       ;       // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


   //   divide clock by 48               (baudrate_divider/2-1))
   //                                         (48/2-1)
   //                                            (23)
   m_flex->TIMCMP[3]    =    23;


   // setup flex timer 4 *****************************************************
   // This is a hack to try to sync the shifter flag to the clocks
   // This design relies on Timer0 and Timer3 to always be running, keeping the data bits on the same
   // bit clock from one word to the next. But a transmit from software is asychronous to this clock,
   // and could be triggerd at any time, on any edge of the 48MHz FlexIO clock. If the trigger occurs
   // at a critical time just before the data shifts, the timers and shifters can get out of sync
   // with each other, and everything falls apart.
   // This timer synchronizes the trigger to the falling edge of Timer3 (1MHz clock), an edge that
   // should be safe for triggering.
   // When SHIFTER1 flag goes high (caused by software writing data to the shifer) this timer will
   // enable on the next falling edge of TIMER3 (1MHz clock). It disables as soon as the SHIFTER1 flag
   // goes low, which is caused by the data being loaded into the shifter.
   m_flex->TIMCTL[4]    =
           FLEXIO_TIMCTL_TRGSEL( 5 )      |        // shifter 1 status flag =(1 * 4) + 1
           FLEXIO_TIMCTL_TRGPOL           |        // trigger active low
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 0 )      |        // timer pin is an input
           FLEXIO_TIMCTL_PINSEL( FLEX_1553TX_PIN_TIM3_OUT )     |        // pin input from 1MHz clock
           FLEXIO_TIMCTL_PINPOL           |        // timer pin active low
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit mode

   m_flex->TIMCFG[4]    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           //FLEXIO_TIMCFG_TIMDEC( 2 )      |        // decrement on pin input, shift clock = pin input
           //FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMDEC( 1 )      |        // decrement on trigger, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 6 )      |        // disable timer on trigger falling edge
           //FLEXIO_TIMCFG_TIMENA( 3 )      |        // enable timer on (inverted) trigger high & pin high
           FLEXIO_TIMCFG_TIMENA( 5 )      |        // enable timer on pin rising edge AND trigger high
           FLEXIO_TIMCFG_TSTOP(  0 )       ;       // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

   //m_flex->TIMCMP[4]    =   0x1;
   m_flex->TIMCMP[4]    =   0xffff;


   // setup flex timer 5 *****************************************************
   // this is part of a hack to try to sync the shifter flag to the clocks
   // It is no longer needed - a better fix was found
   // This basically transfers the Enable from TIMER4 to a pin output
   // It can still be used to make the TIMER4 output visible on a Teensy pin for debug
   m_flex->TIMCTL[5]    =
           //FLEXIO_TIMCTL_TRGSEL( 36 )     |        // Pin 18 (2MHz clock) =(pin * 2)
           FLEXIO_TIMCTL_TRGSEL( 0 )      |        // not used
           FLEXIO_TIMCTL_TRGPOL           |        // trigger active low
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( FLEX_1553TX_PIN_TIM5_OUT )     |        // timer pin 19 (for debug only)
           FLEXIO_TIMCTL_PINPOL           |        // timer pin active low
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit mode

   m_flex->TIMCFG[5]    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic low when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 1 )      |        // decrement on trigger, shift clock = timer output
           //FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 1 )      |        // disable timer on timer N-1 disable
           //FLEXIO_TIMCFG_TIMENA( 3 )      |        // enable timer on (inverted) trigger high & pin high
           FLEXIO_TIMCFG_TIMENA( 1 )      |        // enable timer on timer N-1 enable
           FLEXIO_TIMCFG_TSTOP(  0 )       ;       // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

   m_flex->TIMCMP[5]    =   0xffff;


     // setup flex timer 7 *****************************************************
   // for debug only
   // this just passes the trigger thru to an IO pin for debug
   // it is always enabled
   m_flex->TIMCTL[7]    =
           FLEXIO_TIMCTL_TRGSEL( 5 )     |        // Shifter1 status flag =(1 * 4) + 1
           //FLEXIO_TIMCTL_TRGSEL( 19 )     |        // Timer4 output =(4 * 4) + 3
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( FLEX_1553TX_PIN_TIM7_OUT )      |        // timer pin 9 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

   m_flex->TIMCFG[7]    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trigger input (both edges), Shift clock equals Trigger input.
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


   // enable FLEXIO1
   m_flex->CTRL |= 1;    // enable FLEXIO1 module
   m_just_configured = true;

   return( true );
}





// Sends one command word on bus, using FlexIO1
// If transmitter is busy, this will wait for it to become avilable.
// @param  rdaddress:   address of the device to send to
// @param  subaddress:  register number to send data to
// @param  wordcount:   number of data bytes to follow (1 to 32)
// @return error code:  0=success, -1=Flex clock disabled, -2=timeout
int FlexIO_1553TX::send_command( byte rtaddress, byte subaddress, byte wordcount )
{
   uint16_t data;

   data = (rtaddress & 0x1f) << 11 | (subaddress & 0x1f) << 5 | (wordcount & 0x1f);
   return( send( FLEX1553_COMMAND_WORD, data) );
}



// Send one data word on bus, using FlexIO1
// If transmitter is busy, this will wait for it to become avilable.
// @param  data:   16-bit data
// @return error code: 0=success, -1=Flex clock disabled, -2=timeout
int FlexIO_1553TX::send_data( uint16_t data )
{
   return( send( FLEX1553_DATA_WORD, data) );
}



// Generic send command
// Sends one word on bus, using FlexIO1
// If transmitter is busy, this will wait for it to become avilable.
// @param  sync:   0=data sync, 1=command or status sync
// @param  data:   16-bit data
// @return error code: 0=success, -1=Flex clock disabled, -2=timeout
int FlexIO_1553TX::send( uint8_t sync, uint16_t data )
{
   uint32_t shiftData;
   uint32_t time;
   int status = 0;

   // make sure Flex1 clock is enabled
    if( !clock_running() )
       return( -1 );  // code will hang if Flex clock not enabled

   // write output data to shifter
   // The first three bits form a SYNC pulse, which behave differently than the
   // data bits. The FlexIO state machine will treat these bit positions special
   // due to the control bits loaded into SHIFTBUF2, do not use any other codes here.
   if( sync == FLEX1553_COMMAND_WORD )
      shiftData =  0xC0000000U; // 110b
   else
      shiftData =  0x20000000U; // 001b

   shiftData = shiftData | ((uint32_t)data << 13) | ((uint32_t)parity(data) << 12);

   // wait for transmitter avaliable
   time = micros();
   while(1) {
      if( transmitter_busy() == 0 )
         break;
      if( (micros() - time) > 100 ) { // or timeout
         status = -2;  // timeout
         break;
      }
   }

   //shiftData = FLEXIO3_SHIFTBUF3; // this is a dummy read to clear the RX shifter error flag

   //  If all is well, send the data
   if( status == 0 ) {
      // the shifter sends LSB first, using BIS function reverses the bit
      // order of the data, so effectively, we are sending MSB first.
      //FLEXIO1_SHIFTBUFBIS1 = shiftData;  // start transimision
      m_flex->SHIFTBUFBIS[1] = shiftData; // start transimision
      //FLEXIO1_TIMSTAT   = 7;          // reset timer status bits, these are used to determine when
      m_flex->TIMSTAT = 7;    // reset timer status bits, these are used to determine when
                              // transmission is complete
      m_just_configured = false;
   }

   return( status );
}



int FlexIO_1553TX::transmitter_busy( void )
{
   int flags;
   int status;

   // the usual "tranmitter empty" flag does not seem to work with FlexIO
   // writing the second word before the transmitter is done will cause it
   // to stop working. The code does not hang, but the Flex module will
   // no longer trigger, until it has been reset.
   // There seem to be two valid flag states with this specific setup
   // where flags = (FLEXIO2_TIMSTAT << 8) | FLEXIO2_SHIFTSTAT
   //    each bit is a flag for one timer or shifter
   // 0x0003 = immediatly after configuration, shifters 0 and 1 will show empty
   //          shifter 2 was loaded by the configuration, so it shows full
   //          timers have not been triggered, so their status is 0
   //          BUT, this condition can also occur on subsiquent transmissions
   //          durring the shift, tricking the code into thinking it is done.
   // 0x0707 = after data has been sent and transmission is complete
   //          shifters 0, 1 and 2 all show empty
   //          timers 0, 1, and 2 show a timeout
   //          BUT, the processor is so crazy fast, it can check this status again
   //          and load a second word into the transmitter, before the HARDWARE
   //          has time to clear the status flags! So the timer flags must be
   //          cleared by software after writing the FLEXIO2_SHIFTBUF1 reg
   // Any other status indicates that the FlexIO transmit is not done

   // make sure Flex1 clock is enabled
    if( !clock_running() )
       return( -1 );  // will hang if Flex clock not enabled

   //flags = (FLEXIO1_TIMSTAT << 8) | FLEXIO1_SHIFTSTAT;
   flags = (m_flex->TIMSTAT << 8) | m_flex->SHIFTSTAT;
   //if( flags == 0x0707 ) // normal flags
   if( flags & 2 ) // data shifter empty
      status = 0;
   else if( (flags == 3) && m_just_configured ) // only used by the first write
      status = 0;
   else
      status = 1;  // not ready

   return( status );
}


// get status flags for 8 timers and 8 shifters in FlexIO1
// @return  8 timer flags : 8 shifter flags (one byte for each)
unsigned long FlexIO_1553TX::get_status( void )
{
  unsigned long flags;

  // make sure Flex1 clock is enabled
  if( (CCM_CCGR5 & 0xC) == 0 )
    return( -1 );  // can not read status if FlexIO1 clock is disabled

  //flags = (FLEXIO1_TIMSTAT << 8) | FLEXIO1_SHIFTSTAT; // will hang if Flex clock not enabled
  flags = (FLEXIO1_SHIFTERR << 16) | (FLEXIO1_SHIFTSTAT << 8) | FLEXIO1_TIMSTAT;
  FLEXIO1_SHIFTERR  = 0xff;  // clear flags
  FLEXIO1_SHIFTSTAT = 0xff;
  FLEXIO1_TIMSTAT   = 0xff;
  return( flags );
}



// Controls the pin MUX to enable or disable the 1553 outputs.
// If transmitter is busy, this will wait for it to empty before changing the outputs.
// @param  ch:    0=transmit on pair 1, 1=transmit on pair 2, etc,
//                4=transimt on all allowed channels
//                any other value will disable all channels
// @return error code: 0=success, -1=Flex clock disabled, -2=timeout, -3=illegal configuration
int FlexIO_1553TX::set_channel( int ch )
{
   uint32_t time;

   // this function changes the pin MUX to enable or disable the
   // outputs from the 1553 state machine. When enabled, these two
   // differential outputs have identical information on them, and
   // when disabled, they have zeros from the GPIO drivers.
   // Their only purpose is to switch between two different TX circuits

   //#ifndef FLEX01_TX_CHB
   //  return( -3 ); // there is only one channel configured!
   //#endif

    if( ch == m_chan )
       return( 0 );   // no change needed

    if( ch > 4)
      return -3;  // out of range

    if( ch < 4 && m_pair[ch].allowed == false )
      return -3;  // trying to set a channel disallowed in constructor

   // make sure Flex1 clock is enabled
    if( !clock_running() )
       return( -1 );

   // wait for transmitter to empty before changing
   time = micros();
   while(1) {
      if( transmitter_busy() == 0 )
         break;
      if( (micros() - time) > 100 ) { // or timeout
         return( -2 );  // timeout
         break;
      }
   }

   for( int i=0; i<4; i++ ) {
      if( m_pair[i].allowed ) {
         if( ch == i || ch == 4 ) {
            // turn this pair on
            setPinMux( m_pair[i].t_posPin, m_altFlex);
            setPinMux( m_pair[i].t_negPin, m_altFlex);
         }
         else {
            // turn this pair off
            setPinMux( m_pair[i].t_posPin, m_altGpio);
            setPinMux( m_pair[i].t_negPin, m_altGpio);
         }
      }
   }

   //if( ch & FLEX1553_CH_A ) { // if Channel A is to be enabled
   //  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04 = 4;     // FLEXIO04     Teensy pin 2
   //  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05 = 4;     // FLEXIO05     Teensy pin 3
   //}
   //else {  // Channel A is to be disabled
   //  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04 = 5;     // GPIO4_IO04   Teensy pin 2
   //  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05 = 5;     // GPIO4_IO05   Teensy pin 3
   //}
   //
   //if( ch & FLEX1553_CH_B ) { // if Channel B is to be enabled
   //  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06 = 4;     // FLEXIO06     Teensy pin 4
   //  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07 = 4;     // FLEXIO07     Teensy pin 33
   //}
   //else {  // Channel B is to be disabled
   //  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06 = 5;     // GPIO4_IO06   Teensy pin 4
   //  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07 = 5;     // GPIO4_IO07   Teensy pin 33
   //}

   m_chan = ch;
   return( 0 );
}


// This is the latest working verion
// still having trouble with the start flag happening just before a clock edge, wihch causes shiter and state mahcine to be out of sync
// Configures FlexIO2 as a 1553 transmitter
// @return  always returns zero
//int Flex2_1553TX_config(void)
//{
//  // pins used by this module
//  #define FLEX2_1553_PIN_TIM0_OUT  18    // for debug only
//  //#define FLEX2_1553_PIN_TIM1_OUT  19    // for debug only
//     // the following 3 pins must stay sequential, they are used as
//     // inputs to the state machine
//  #define FLEX2_1553_PIN_SHFT1_OUT 10    // 6
//  #define FLEX2_1553_PIN_SHFT2_OUT 11    // 9
//  #define FLEX2_1553_PIN_TIM2_OUT  12    // for debug only
//  #define FLEX2_1553_PIN_TIM3_OUT  19    // for debug only
//  #define FLEX2_1553_PIN_TIM7_OUT  28    // for debug only
//  #define FLEX2_1553_PIN_TIM5_OUT  29    // for debug only
//  // four more pins are used for the state machine output
//  // but they are pre-assigned to FlexIO[1:0] and configured
//  // in a different way
//
//  // setup flex clock
//  // the Flex clock MUST BE CONFIGURED FIRST. Accessing and Flex register without
//  // a clock, will hang the code.
//  // The default clock speed is 30MHz and I need 2MHz, so I would like to use
//  // my baud rate divider to divide by 15. Unfortanuatly, the way the baud
//  // dividers work, you need can only divide by an even number. So I need
//  // to change the flex clock speed.
//  CCM_CS1CDR &= ~( CCM_CS1CDR_FLEXIO2_CLK_PODF( 7 ) ); // clear flex clock bits
//  CCM_CS1CDR |= CCM_CS1CDR_FLEXIO2_CLK_PODF( 4 );   // set flex clock = 48MHz
//                                                    // clock speed = 480MHz/(N+1)
//  CCM_CCGR3 |= CCM_CCGR3_FLEXIO2(CCM_CCGR_ON);      // enable clock
//
//  // if the Flex module gets hung up, reconfiguring will not fix it, you will
//  // need to reset it. Flex module should be disabled during configuration or
//  // else you will likely get "random" output transitions during config.
//  // Reset and disable FLEXIO2 (clock MUST be enabled or this will hang)
//  FLEXIO2_CTRL |= 2;    // reset Flex module
//  FLEXIO2_CTRL &= 0xfffffffc;  // release reset and leave Flex disabled
//
//  // route IO pins to FlexIO 2
//    // final output from state machine
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_00 = 4;      // FLEXIO pin0    Teensy pin 10
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01 = 4;      // FLEXIO pin1    Teensy pin 12
//  //IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02 = 4;    // FLEXIO pin2    Teensy pin 11
//    // inputs to state machine
//#ifdef FLEX02_DEBUG
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_10 = 4;      // FLEXIO pin10   Teensy pin 6
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_11 = 4;      // FLEXIO pin11   Teensy pin 9
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_12 = 4;      // FLEXIO pin12   Teensy pin 32
//    // 2MHz timer output
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_03 = 4;      // FLEXIO pin19   Teensy pin 37
//
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_02 = 4;      // FLEXIO pin18   Teensy pin 36
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_12 = 4;      // FLEXIO pin28   Teensy pin 35
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_B1_13 = 4;      // FLEXIO pin29   Teensy pin 34
//#endif
//
//  // State Machine **************************************************
//  // This uses five shifters as a five-state state machine to produce Manchester II
//  // biphase encoded data bits
//  //  state 0 = outputs disabled
//  //  state 4 = first  half of a "1" state
//  //  state 6 = second half of a "1" state
//  //  state 7 = first  half of a "0" state
//  //  state 5 = second half of a "0" state
//  // all 5 shifters are set the same, only the state tables are different
//
//  // setup state 0
//  FLEXIO2_SHIFTCTL0  =
//           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
//           //FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
//           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
//           FLEXIO_SHIFTCTL_PINSEL( 10 )   |        // FLEXIO pins 10, 11 & 12 as inputs
//           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
//           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode
//
//  FLEXIO2_SHIFTCFG0  =
//           FLEXIO_SHIFTCFG_PWIDTH( 0xf )  |        // disable FXIO_D[7:4] outputs
//           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
//           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
//           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable  FXIO_D[1:0] outputs
//                                                   //    Teensy pins 12, 10
// // setup state 4
//  FLEXIO2_SHIFTCTL4  =
//           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
//           //FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
//           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
//           FLEXIO_SHIFTCTL_PINSEL( 10 )   |        // FLEXIO pins 10, 11 & 12 as inputs
//           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
//           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode
//
//  FLEXIO2_SHIFTCFG4  =
//           FLEXIO_SHIFTCFG_PWIDTH( 0xf )  |        // disable FXIO_D[7:4] outputs
//           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
//           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
//           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable  FXIO_D[1:0] outputs
//                                                   //    Teensy pins 12, 10
//
// // setup state 5
//  FLEXIO2_SHIFTCTL5  =
//           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
//           //FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
//           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
//           FLEXIO_SHIFTCTL_PINSEL( 10 )   |        // FLEXIO pins 10, 11 & 12 as inputs
//           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
//           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode
//
//  FLEXIO2_SHIFTCFG5  =
//           FLEXIO_SHIFTCFG_PWIDTH( 0xf )  |        // disable FXIO_D[7:4] outputs
//           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
//           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
//           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable  FXIO_D[1:0] outputs
//                                                   //    Teensy pins 12, 10
//
// // setup state 6
//  FLEXIO2_SHIFTCTL6  =
//           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
//           //FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
//           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
//           FLEXIO_SHIFTCTL_PINSEL( 10 )   |        // FLEXIO pins 10, 11 & 12 as inputs
//           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
//           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode
//
//  FLEXIO2_SHIFTCFG6  =
//           FLEXIO_SHIFTCFG_PWIDTH( 0xf )  |        // disable FXIO_D[7:4] outputs
//           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
//           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
//           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable  FXIO_D[1:0] outputs
//                                                   //    Teensy pins 12, 10
//
// // setup state 7
//  FLEXIO2_SHIFTCTL7  =
//           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
//           //FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
//           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
//           FLEXIO_SHIFTCTL_PINSEL( 10 )   |        // FLEXIO pins 10, 11 & 12 as inputs
//           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
//           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode
//
//  FLEXIO2_SHIFTCFG7  =
//           FLEXIO_SHIFTCFG_PWIDTH( 0xf )  |        // disable FXIO_D[7:4] outputs
//           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
//           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
//           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable  FXIO_D[1:0] outputs
//                                                   //    Teensy pins 12, 10
//
//  // load state lookup table               output  : next state
//  FLEXIO2_SHIFTBUF0 =  0x009E7000U;  //  0000 0000 : 100 111 100 111 000 000 000 000b
//  FLEXIO2_SHIFTBUF4 =  0x01DADDADU;  //  0000 0001 : 110 110 101 101 110 110 101 101b
//  FLEXIO2_SHIFTBUF7 =  0x02B76B76U;  //  0000 0010 : 101 101 110 110 101 101 110 110b
//  FLEXIO2_SHIFTBUF5 =  0x019E7000U;  //  0000 0001 : 100 111 100 111 000 000 000 000b
//  FLEXIO2_SHIFTBUF6 =  0x029E7000U;  //  0000 0010 : 100 111 100 111 000 000 000 000b
//
//  // setup data shifter 1 **************************************************
//  // this is the data shifter. writing data to SHIFTBUF1 will trigger the transmit
//  // 21 bits are used. The first 3 (LSB) for the Sync, 16 bits of data, one parity,
//  // and the last bit (MSB) is used to turn off the transmitter
//  FLEXIO2_SHIFTCTL1  =
//           FLEXIO_SHIFTCTL_TIMSEL( 1 )    |        // controlled from timer 1
//           // FLEXIO_SHIFTCTL_TIMPOL      |        // on positive edge
//           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // pin output enabled
//           FLEXIO_SHIFTCTL_PINSEL( FLEX2_1553_PIN_SHFT1_OUT )   |        // FLEXIO pin 10    Teensy pin 6  (for debug only)
//           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
//           FLEXIO_SHIFTCTL_SMOD( 2 );              // transmit mode
//
//  FLEXIO2_SHIFTCFG1  =
//           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
//           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
//           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
//           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled
//
//  // setup data shifter 2 **************************************************
//  // this shfiter is used for control bits, which will modify the data
//  // both shifters shift data out at the same time
//  // A zero in this shifter causes the same bit postion in the data shifter
//  // to be output without transition. A one will cause the data bit to
//  // transition: 0 = 0 to 1, 1 = 1 to 0
//  FLEXIO2_SHIFTCTL2  =
//           FLEXIO_SHIFTCTL_TIMSEL( 1 )    |        // controlled from timer 1
//           // FLEXIO_SHIFTCTL_TIMPOL      |        // on positive edge
//           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // pin output enabled
//           FLEXIO_SHIFTCTL_PINSEL( FLEX2_1553_PIN_SHFT2_OUT )   |        // FLEXIO pin 11    Teensy pin 9  (for debug only)
//           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
//           FLEXIO_SHIFTCTL_SMOD( 2 );              // transmit mode
//
//  FLEXIO2_SHIFTCFG2  =
//           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
//           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
//           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
//           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled
//
//  // the control bits are always the same. remember LSB first
//  // the shifter will reload the same data each time TIMER1 is triggered
//  FLEXIO2_SHIFTBUF2 =  0x0ffffaU;  //   1111 1111 1111 1111 1010b;
//  //FLEXIO2_SHIFTBUF2 =  0x0000000U;   // for debug: SM should output raw data from shifter 1
//
//  // setup flex timer 0 *****************************************************
//  // this is a 2MHz clock to step the state machine
//  // it is clocked from from the FLEXIO clock
//  // it is enabled by Shifter 1 status flag
//  FLEXIO2_TIMCTL0    =
//           FLEXIO_TIMCTL_TRGSEL( 5 )      |        // not used
//           //FLEXIO_TIMCTL_TRGPOL           |        // trigger active high
//           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
//           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
//           FLEXIO_TIMCTL_PINSEL( FLEX2_1553_PIN_TIM0_OUT )     |        // timer pin 19 (for debug only)
//           // FLEXIO_TIMCTL_PINPOL           |        // timer pin active low
//           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit mode
//
//  FLEXIO2_TIMCFG0    =
//           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
//           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
//           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
//           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
//           FLEXIO_TIMCFG_TIMENA( 0 )      |        // always enabled
//           FLEXIO_TIMCFG_TSTOP(  0 )       ;       // stop bit disabled
//           // FLEXIO_TIMCFG_TSTART                 // start bit disabled
//
//
//  //   divide clock by 24               (baudrate_divider/2-1))
//  //                                         (24/2-1)
//  //                                            (11)
//  FLEXIO2_TIMCMP0    =    11;
//
//
//  // setup flex timer 1 *****************************************************
//  // this is a counter to track the bit count for both shifters
//  // it is clocked from Timer3 (1MHz)
//  // it is enabled by Shifter 1 status flag
//  FLEXIO2_TIMCTL1    =
//           //FLEXIO_TIMCTL_TRGSEL( 5 )      |        // shifter 1 status flag =(1 * 4) + 1
//           //FLEXIO_TIMCTL_TRGSEL( 58 )      |        // Pin 29 (Timer5 output)
//           FLEXIO_TIMCTL_TRGSEL( 23 )      |        // Timer5 out (N * 4) + 3
//           //FLEXIO_TIMCTL_TRGPOL           |        // trigger active low
//           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
//           FLEXIO_TIMCTL_PINCFG( 0 )      |        // timer pin output disabled
//           FLEXIO_TIMCTL_PINSEL( FLEX2_1553_PIN_TIM3_OUT )   |   // used as the clock input
//           FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
//           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode
//           //FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit counter mode
//
//  FLEXIO2_TIMCFG1    =
//           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
//           FLEXIO_TIMCFG_TIMDEC( 2 )      |        // decrement on pin input, shift clock = pin input
//           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
//           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
//           FLEXIO_TIMCFG_TIMENA( 2 )      |        // enable timer on (inverted) trigger high
//           //FLEXIO_TIMCFG_TIMENA( 3 )      |        // enable timer on (inverted) trigger high & pin high
//           //FLEXIO_TIMCFG_TIMENA( 1 )      |        // Timer enabled on Timer N-1 enable
//                  // this is needed to prevent a timing synchronization fault that
//                  // occurs occasionally if the trigger occurs too close to the clock edge
//           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
//           // FLEXIO_TIMCFG_TSTART                 // start bit disabled
//
//  //  We are shifting 20 bits of data
//  //  20 shifts,  divide clock by 1      ((n*2-1)<<8) | (baudrate_divider/2-1))
//  //                                     (20*2-1)<<8  | (1/2-1)
//  //                                         (39)<<8  | (0)
//  //                                          0x2700  | 0x0
//  FLEXIO2_TIMCMP1    =    0x2700;
//  //FLEXIO2_TIMCMP1    =    0x27;
//
//  // setup flex timer 2 *****************************************************
//  // This produced the Enable input to the state machine which
//  // will disable the output at the end of the transmission.
//  // This timer produces a .525us delay, which is reset after
//  // each edge of Timer1 output (500us edges). Thus, the timer
//  // output will stay high until .525us after Timer1 stops.
//  // clocked from flex clock
//  // enabled by Timer1 enable
//  // reset by Timer 1 output
//  // disabled by compare (timeout)
//  FLEXIO2_TIMCTL2    =
//           FLEXIO_TIMCTL_TRGSEL( 7 )      |        // triggered by Timer 1 trigger output =(1 * 4) + 3
//           //FLEXIO_TIMCTL_TRGSEL( 5 )      |        // shifter 1 status flag =(1 * 4) + 1
//           FLEXIO_TIMCTL_TRGPOL           |        // trigger active high
//           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
//           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
//           FLEXIO_TIMCTL_PINSEL( FLEX2_1553_PIN_TIM2_OUT )     |        // timer pin 12 (wired to state machine)
//           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
//           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer
//
//  FLEXIO2_TIMCFG2    =
//           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
//           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // Decrement on Flex clock
//           FLEXIO_TIMCFG_TIMRST( 7 )      |        // reset on trigger, both edges
//           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // Timer disabled on timer compare
//           FLEXIO_TIMCFG_TIMENA( 1 )      |        // Timer enabled on Timer N-1 enable
//           //FLEXIO_TIMCFG_TIMENA( 3 )      |        // enable timer on (inverted) trigger high & pin high
//           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
//           // FLEXIO_TIMCFG_TSTART                 // start bit disabled
//
//           // divide Flex clock by 48 to get 0.50us
//           //                         (baudrate_divider/2-1))
//           //                         (48/2-1)
//           //                         (23)
//           // time = (25 + 1)/48  = .542us
//  FLEXIO2_TIMCMP2    =    25;
//
//
//  // setup flex timer 3 *****************************************************
//  // 1MHz clock for the shifters
//  // This is free running and is always running
//  // it is clocked from from the Flex clock
//  // and is synchronized to Timer0 on the rising edge, simply because
//  // both clocks are started at the same time (at the end of config)
//  FLEXIO2_TIMCTL3    =
//           FLEXIO_TIMCTL_TRGSEL( 3 )      |        // Triggered by Timer0 =(0 * 4) + 3
//           FLEXIO_TIMCTL_TRGPOL           |        // trigger active high
//           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
//           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
//           FLEXIO_TIMCTL_PINSEL( FLEX2_1553_PIN_TIM3_OUT )     |        // timer pin 19 (for debug only)
//           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
//           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit mode
//
//  FLEXIO2_TIMCFG3    =
//           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
//          // FLEXIO_TIMCFG_TIMDEC( 1 )      |        // decrement on Trigger, both edges
//           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on flex clock
//           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
//           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
//           FLEXIO_TIMCFG_TIMENA( 0 )      |        // always enabled
//           FLEXIO_TIMCFG_TSTOP(  0 )       ;       // stop bit disabled
//           // FLEXIO_TIMCFG_TSTART                 // start bit disabled
//
//
//  //   divide clock by 48               (baudrate_divider/2-1))
//  //                                         (48/2-1)
//  //                                            (23)
//  FLEXIO2_TIMCMP3    =    23;
//
//
//  // setup flex timer 4 *****************************************************
//  // this is a hack to try to sync the shifter flag to the clocks
//   FLEXIO2_TIMCTL4    =
//           FLEXIO_TIMCTL_TRGSEL( 5 )      |        // shifter 1 status flag =(1 * 4) + 1
//           FLEXIO_TIMCTL_TRGPOL           |        // trigger active low
//           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
//           FLEXIO_TIMCTL_PINCFG( 0 )      |        // timer pin output enabled
//           FLEXIO_TIMCTL_PINSEL( FLEX2_1553_PIN_TIM3_OUT )     |        // timer pin 19 (for debug only)
//           FLEXIO_TIMCTL_PINPOL           |        // timer pin active low
//           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit mode
//
//  FLEXIO2_TIMCFG4    =
//           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic low when enabled, not affcted by reset
//           FLEXIO_TIMCFG_TIMDEC( 2 )      |        // decrement on pin input, shift clock = pin input
//           //FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
//           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
//           FLEXIO_TIMCFG_TIMDIS( 6 )      |        // disable timer on timer compare
//           //FLEXIO_TIMCFG_TIMENA( 3 )      |        // enable timer on (inverted) trigger high & pin high
//           FLEXIO_TIMCFG_TIMENA( 5 )      |        // enable timer on trigger rising edge
//           FLEXIO_TIMCFG_TSTOP(  0 )       ;       // stop bit disabled
//           // FLEXIO_TIMCFG_TSTART                 // start bit disabled
//
//  //   divide clock by 24               (baudrate_divider/2-1))
//  //                                         (24/2-1)
//  //                                            (11)
//  FLEXIO2_TIMCMP4    =   0x1;
//
//
//  // setup flex timer 5 *****************************************************
//  // this is a hack to try to sync the shifter flag to the clocks
//   FLEXIO2_TIMCTL5    =
//           //FLEXIO_TIMCTL_TRGSEL( 36 )     |        // Pin 18 (2MHz clock) =(pin * 2)
//           FLEXIO_TIMCTL_TRGSEL( 0 )      |        // not used
//           FLEXIO_TIMCTL_TRGPOL           |        // trigger active low
//           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
//           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
//           FLEXIO_TIMCTL_PINSEL( FLEX2_1553_PIN_TIM5_OUT )     |        // timer pin 19 (for debug only)
//           FLEXIO_TIMCTL_PINPOL           |        // timer pin active low
//           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit mode
//
//  FLEXIO2_TIMCFG5    =
//           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic low when enabled, not affcted by reset
//           FLEXIO_TIMCFG_TIMDEC( 1 )      |        // decrement on pin input, shift clock = pin input
//           //FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
//           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
//           FLEXIO_TIMCFG_TIMDIS( 1 )      |        // disable timer on timer N-1 disable
//           //FLEXIO_TIMCFG_TIMENA( 3 )      |        // enable timer on (inverted) trigger high & pin high
//           FLEXIO_TIMCFG_TIMENA( 1 )      |        // enable timer on timer N-1 enable
//           FLEXIO_TIMCFG_TSTOP(  0 )       ;       // stop bit disabled
//           // FLEXIO_TIMCFG_TSTART                 // start bit disabled
//
//  //   divide clock by 24               (baudrate_divider/2-1))
//  //                                         (24/2-1)
//  //                                            (11)
//  FLEXIO2_TIMCMP5    =   0xffff;
//
//
//  // setup flex timer 7 *****************************************************
//  // for debug only
//  // this just passes the trigger thru to an IO pin for debug
//  // it is always enabled
//  FLEXIO2_TIMCTL7    =
//           FLEXIO_TIMCTL_TRGSEL( 5 )     |        // Shifter1 status flag =(1 * 4) + 1
//           //FLEXIO_TIMCTL_TRGSEL( 11 )     |        // Timer 2 trigger output =(2 * 4) + 3
//           //FLEXIO_TIMCTL_TRGSEL( 8 )      |        // Input Pin 4 =(2 * 4) + 0
//           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
//           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
//           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
//           FLEXIO_TIMCTL_PINSEL( FLEX2_1553_PIN_TIM7_OUT )      |        // timer pin 9 (for debug only)
//           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
//           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode
//
//  FLEXIO2_TIMCFG7    =
//           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
//           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trigger input (both edges), Shift clock equals Trigger input.
//           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
//           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
//           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
//           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
//           // FLEXIO_TIMCFG_TSTART                 // start bit disabled
//
//
//  // enable FLEXIO2
//  FLEXIO2_CTRL |= 1;    // enable FLEXIO2 module
//  just_configured2 = true;
//
//  return( 0 );
//}



// Send one word on bus, using FlexIO2
// @param  sync:   0=data sync, 1=command or status sync
// @param  data:   16-bit data
// @return error code: 0=success, -1=Flex clock disabled, -2=timeout
//int Flex2_1553TX_send( uint8_t sync, uint16_t data )
//{
//  uint32_t shiftData;
//  uint32_t time;
//  int status = 0;
//
//  // make sure Flex clock is enabled
//  if( (CCM_CCGR3 & 3) == 0 )
//    return( -1 );  // can not read status if Flex clock is disabled
//
//  // write output data to shifter
//  // the first three bits form a SYNC pulse, which behave differently than the data bits
//  // the sequencer will treat these bit positions special, do not use any other codes here
//  if( sync == FLEX1553_COMMAND_WORD )
//    shiftData =  0xC0000000U; // 110b
//  else
//    shiftData =  0x20000000U; // 001b
//
//  // shifter sends LSB first, order the bits accordingly
//  shiftData = shiftData | ((uint32_t)data << 13) | ((uint32_t)parity(data) << 12);
//
//  // wait for transmitter avaliable
//  time = micros();
//  while(1) {
//    if( Flex2_1553TX_transmitter_busy() == 0 )
//      break;
//    if( (micros() - time) > 100 ) { // or timeout
//      status = -2;  // timeout
//      break;
//    }
//  }
//
//  //  If all is well, send the data
//  if( status == 0 ) {
//    //FLEXIO2_SHIFTBUF1 = shiftData;  // start transimision
//    FLEXIO2_SHIFTBUFBIS1 = shiftData;  // start transimision
//    FLEXIO2_TIMSTAT   = 7;          // reset timer status, these are used to determine when
//                                    // transmission is complete
//    just_configured2 = false;
//  }
//
//  return( status );
//}



//int Flex2_1553TX_transmitter_busy( void )
//{
//  int flags;
//  int status;
//
//  // the usual "tranmitter empty" flag does not seem to work with FlexIO
//  // writing the second word before the transmitter is done will cause it
//  // to stop working. The code does not hang, but the Flex module will
//  // no longer trigger, until it has been reset.
//  // There seem to be two valid flag states with this specific setup
//  // where flags = (FLEXIO2_TIMSTAT << 8) | FLEXIO2_SHIFTSTAT
//  //    each bit is a flag for one timer or shifter
//  // 0x0003 = immediatly after configuration, shifters 0 and 1 will show empty
//  //          shifter 2 was loaded by the configuration, so it shows full
//  //          timers have not been triggered, so their status is 0
//  //          BUT, this condition can also occur on subsiquent transmissions
//  //          durring the shift, tricking the code into thinking it is done.
//  // 0x0707 = after data has been sent and transmission is complete
//  //          shifters 0, 1 and 2 all show empty
//  //          timers 0, 1, and 2 show a timeout
//  //          BUT, the processor is so crazy fast, it can check this status again
//  //          and load a second word into the transmitter, before the HARDWARE
//  //          has time to clear the status flags! So the timer flags must be
//  //          cleared by software after writing the FLEXIO2_SHIFTBUF1 reg
//  // Any other status indicates that the FlexIO transmit is not done
//
//  // make sure Flex clock is enabled
//  if( (CCM_CCGR3 & 3) == 0 )
//    return( -1 ); // can not read status if Flex clock is disabled
//
//  flags = (FLEXIO2_TIMSTAT << 8) | FLEXIO2_SHIFTSTAT; // will hang if Flex clock not enabled
//  //if( flags == 0x0707 ) // normal flags
//  if( flags & 2 ) // data shifter empty
//    status = 0;
//  else if( (flags == 3) && just_configured2 ) // only used by the first write
//    status = 0;
//  else
//    status = 1;  // not ready
//
//  return( status );
//}


// get status flags for 8 timers and 8 shifters in FlexIO2
// @return  8 timer flags : 8 shifter flags (one byte for each)
//int Flex2_1553TX_get_status( void )
//{
//  int flags;
//
//  // make sure Flex clock is enabled
//  if( (CCM_CCGR3 & 3) == 0 )
//    return( -1 ); // can not read status if Flex clock is disabled
//
//  flags = (FLEXIO2_TIMSTAT << 8) | FLEXIO2_SHIFTSTAT; // will hang if Flex clock not enabled
//  return( flags );
//}



uint8_t FlexIO_1553TX::parity( uint32_t data )
{
   uint32_t parity = 0;

   while(data > 0) {         // if it is 0 there are no more 1's to count
      if(data & 0x01) {       // see if LSB is 1
         parity++;             // why yes it is
      }
      data = data >> 1; //shift to next bit
   }

   return (~parity & 0x0001U);  // only need the low bit to determine odd / even
}




/***************************************************************************************
*    Start of 1553 RX Class
***************************************************************************************/

// pins used by this module
#define FLEX1_1553RX_PIN_TIM0_OUT  10    // 2 MHz state machine clock
#define FLEX1_1553RX_PIN_TIM1_OUT   5    // 1 MHz shift clock
#define FLEX1_1553RX_PIN_TIM2_OUT   8    // 5 MHz clock
#define FLEX1_1553RX_PIN_TIM7_OUT   9    // for debug only
#define FLEX1_1553RX_PIN_SHFT1_IN   0    // data bits from state machine
#define FLEX1_1553RX_PIN_SHFT2_IN   1    // fault bits from state machine
#define FLEX1_1553RX_PIN_SHFT3_IN   4    // 1553 data in
#define FLEX1_1553RX_PIN_DATA_IN    4    // data input pin

#define FLEX2_1553RX_PIN_TIM0_OUT  10    // 2 MHz state machine clock
#define FLEX2_1553RX_PIN_TIM1_OUT   5    // 1 MHz shift clock
#define FLEX2_1553RX_PIN_TIM2_OUT   8    // 5 MHz clock
#define FLEX2_1553RX_PIN_TIM7_OUT   9    // for debug only
#define FLEX2_1553RX_PIN_SHFT1_IN   0    // data bits from state machine
#define FLEX2_1553RX_PIN_SHFT2_IN   1    // fault bits from state machine
#define FLEX2_1553RX_PIN_SHFT3_IN   4    // 1553 data in
#define FLEX2_1553RX_PIN_DATA_IN    4    // data input pin

#define FLEX3_1553RX_PIN_TIM0_OUT  10    // 2 MHz state machine clock
#define FLEX3_1553RX_PIN_TIM1_OUT   5    // 1 MHz shift clock
#define FLEX3_1553RX_PIN_TIM2_OUT   8    // 5 MHz clock
#define FLEX3_1553RX_PIN_TIM7_OUT   9    // for debug only
#define FLEX3_1553RX_PIN_SHFT1_IN   0    // data bits from state machine
#define FLEX3_1553RX_PIN_SHFT2_IN   1    // fault bits from state machine
// #define FLEX3_1553RX_PIN_SHFT3_IN   4    // 1553 data in
#define FLEX3_1553RX_PIN_DATA_IN    4    // data input pin

// big ugly macro that decides which of the FLEX pin definitions to use
#define FLEX_1553RX_PIN_TIM0_OUT    FLEX3_1553RX_PIN_TIM0_OUT
#define FLEX_1553RX_PIN_TIM1_OUT    FLEX3_1553RX_PIN_TIM1_OUT
#define FLEX_1553RX_PIN_TIM2_OUT    FLEX3_1553RX_PIN_TIM2_OUT
#define FLEX_1553RX_PIN_TIM7_OUT    FLEX3_1553RX_PIN_TIM7_OUT
#define FLEX_1553RX_PIN_SHFT1_IN    FLEX3_1553RX_PIN_SHFT1_IN
#define FLEX_1553RX_PIN_SHFT2_IN  ((int8_t)((m_flex_num == 1)? FLEX1_1553RX_PIN_SHFT2_IN : ((m_flex_num == 2)? FLEX2_1553RX_PIN_SHFT2_IN : FLEX2_1553RX_PIN_SHFT2_IN)))
//#define FLEX_1553RX_PIN_DATA_IN   ((int8_t)((m_flex_num == 1)? FLEX1_1553RX_PIN_DATA_IN : ((m_flex_num == 2)? FLEX2_1553RX_PIN_DATA_IN : FLEX2_1553RX_PIN_DATA_IN)))


FlexIO_1553RX::FlexIO_1553RX(uint8_t flex_num, uint8_t rxPin)
   :FlexIO_Base(flex_num, 48.0)
{
   m_rxPin    = rxPin;
   m_altFlex  = (m_flex_num == 3)? 9 : 4; // FlexIO3 uses ALT9, FLEXIO1 & 2 use ALT4
   m_altGpio  = 5;  // gpio always uses Alt5
}


bool FlexIO_1553RX::begin( void )
{
   if( FlexIO_Base::begin() == false )  // configures pll divider
      return false;

   if( config_flex() ==  false )
      return false;

   if( config_io_pins() == false )
      return false;

   return true;
}


bool FlexIO_1553RX::config_io_pins(void)
{
   // route IO pins to FlexIO 3
    // 1553 input bit stream
   IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04 = 9;      // FLEXIO pin4    Teensy pin 40
   int8_t fPin = 4;
   setPinMux( getTeensyPin(fPin) );
#ifdef FLEX03_DEBUG  // bring out internal signals
    // Timer 0,1,2 outputs  - for debug only
   IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10 = 9;      // FLEXIO pin10   Teensy pin 20
   IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05 = 9;      // FLEXIO pin5    Teensy pin 41
   IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 9;      // FLEXIO pin8    Teensy pin 22
     // Compare output      - for debug only
   IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 9;      // FLEXIO pin9    Teensy pin 23
     // State machine out / shifter in - for debug only
   IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00 = 9;      // FLEXIO pin0    Teensy pin 19
   IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01 = 9;      // FLEXIO pin1    Teensy pin 18
#endif
   return true;
}


uint8_t FlexIO_1553RX::parity( uint32_t data )
{
   uint32_t parity = 0;

   while(data > 0) {         // if it is 0 there are no more 1's to count
      if(data & 0x01) {       // see if LSB is 1
         parity++;             // why yes it is
      }
      data = data >> 1; //shift to next bit
   }

   return (~parity & 0x0001U);  // only need the low bit to determine odd / even
}



// configure 1553 receiver on FlexIO 3
bool FlexIO_1553RX::config_flex(void)
{
  // setup flex clock
  // note: FlexIO2 and FlexIO3 share the same clock
 // CCM_CS1CDR &= ~( CCM_CS1CDR_FLEXIO2_CLK_PODF( 7 ) ); // clear flex clock bits
 // CCM_CS1CDR |= CCM_CS1CDR_FLEXIO2_CLK_PODF( 4 );   // set flex clock = 40MHz
 //                                                   // clock speed = 480MHz/(N+1)
 // CCM_CCGR3 |= CCM_CCGR3_FLEXIO2(CCM_CCGR_ON);      // enable clock


   // Check that the Flex clock is enabled
   // The flex clock should already be configured at this point.
   // The Flex clock MUST BE CONFIGURED before accessing any Flex register
   // or else the code will hang.
   if( !clock_running() )
      return(false);  // abort

   // if the Flex module gets hung up, reconfiguring will not fix it, you will
   // need to reset it. Flex module should be disabled during configuration or
   // else you will likely get "random" output transitions during config.
   // Reset and disable FLEXIO3 (clock MUST be enabled or this will hang)
   m_flex->CTRL |= 2;    // reset Flex module
   m_flex->CTRL &= 0xfffffffc;  // release reset and leave Flex disabled

//  // route IO pins to FlexIO 3
//    // 1553 input bit stream
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04 = 9;      // FLEXIO pin4    Teensy pin 40
//#ifdef FLEX03_DEBUG  // bring out internal signals
//    // Timer 0,1,2 outputs  - for debug only
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10 = 9;      // FLEXIO pin10   Teensy pin 20
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_05 = 9;      // FLEXIO pin5    Teensy pin 41
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 9;      // FLEXIO pin8    Teensy pin 22
//    // Compare output      - for debug only
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 9;      // FLEXIO pin9    Teensy pin 23
//    // State machine out / shifter in - for debug only
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_00 = 9;      // FLEXIO pin0    Teensy pin 19
//  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_01 = 9;      // FLEXIO pin1    Teensy pin 18
//#endif

   // setup flex timer 0 *****************************************************
   // this is a 2MHz clock to step the state machine
   // it is clocked from from the FLEXIO clock
   // it is enabled by Shifter 3 status flag (TBD)
   m_flex->TIMCTL[0]    =
           //FLEXIO_TIMCTL_TRGSEL( 13 )      |       // triggered by Shifter3 compare (N*4) +1
           FLEXIO_TIMCTL_TRGSEL( 8 )      |        // Input Pin 4 =(2 * 4) + 0
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( FLEX_1553RX_PIN_TIM0_OUT )     |        // timer pin 10 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

   m_flex->TIMCFG[0]    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // enable timer on trigger rising
           FLEXIO_TIMCFG_TSTOP(  0 )       ;       // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

   //  40 clocks,  divide clock by 24     ((n*2-1)<<8) | (baudrate_divider/2-1))
   //                                     (40*2-1)<<8  | (24/2-1)
   //                                         (79)<<8  | (11)
   //                                          0x4F00  | 0x0b
   m_flex->TIMCMP[0]   =    0x4F0b;


   // setup flex timer 1 *****************************************************
   // this is a 1MHz clock to step both shifters
   // it is clocked from from the FLEXIO clock
   // it is enabled by TBD
   m_flex->TIMCTL[1]    =
           //FLEXIO_TIMCTL_TRGSEL( 13 )     |       // Try Shifter3 status flag =(3 * 4) + 1
           FLEXIO_TIMCTL_TRGSEL( 8 )      |        // Input Pin 4 =(2 * 4) + 0)
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( FLEX_1553RX_PIN_TIM1_OUT )     |        // timer pin 11 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

   m_flex->TIMCFG[1]    =
           FLEXIO_TIMCFG_TIMOUT( 1 )      |        // timer output = logic low when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // enable timer on trigger rising
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

   // 20 shifts are needed to clock in the data, and one more shift is needed
   // to STORE the data into the Shift Buffer. If only 20 clocks are provided,
   // the last bit (parity) will not be captured.
   // It seems that just a half clock is needed to store the data. This extra
   // half clock is not visible in the timer output line, but does capture all
   // 20 bits.
   //
   // 20-1/2 shifts,  divide clock by 48  ((n*2-1)<<8) | (baudrate_divider/2-1))
   //                                   (20.5*2-1)<<8  | (48/2-1)
   //                                         (40)<<8  | (23)
   //                                          0x2800  | 0x17
   m_flex->TIMCMP[1]  =  0x2817;


   // setup flex timer 2 *****************************************************
   // this is a 6MHz clock for shifter 3
   // it is clocked from from the FLEXIO clock
   // it is always enabled
   m_flex->TIMCTL[2]    =
            FLEXIO_TIMCTL_TRGSEL( 0 )      |        // trigger not used
            //FLEXIO_TIMCTL_TRGPOL         |        // trigger not used
            FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
            FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
            FLEXIO_TIMCTL_PINSEL( FLEX_1553RX_PIN_TIM2_OUT )      |        // timer pin 8 (for debug only)
            // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
            //FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode
            FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

   m_flex->TIMCFG[2]    =
            FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
            FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
            FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
            FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
            FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
            FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
            // FLEXIO_TIMCFG_TSTART                 // start bit disabled

   //  Flex clock = 48MHz, we want 6MHz, so divide by 8
   //  TIMCMP = divider/2-1 = 8/2-1 = 3
   //FLEXIO3_TIMCMP2    =    0xffff0003U;
   m_flex->TIMCMP[2]    =    0x0003U;


   // setup flex timer 7 *****************************************************
   // for debug only
   // this just passes the trigger thru to an IO pin for debug
   // it is always enabled
   m_flex->TIMCTL[7]    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |        // Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGSEL( 11 )     |        // Timer 2 trigger output =(2 * 4) + 3
           //FLEXIO_TIMCTL_TRGSEL( 8 )      |        // Input Pin 4 =(2 * 4) + 0
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( FLEX_1553RX_PIN_TIM7_OUT )      |        // timer pin 9 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

   m_flex->TIMCFG[7]    =
           FLEXIO_TIMCFG_TIMOUT( 1 )      |        // timer output = logic low when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trigger input (both edges), Shift clock equals Trigger input.
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


   // setup data shifter 1 **************************************************
   // This shifter is configured in receive Mode
   // It captures the data bits from the state machine decoder
   m_flex->SHIFTCTL[1]  =
           FLEXIO_SHIFTCTL_TIMSEL( 1 )    |        // clocked from timer 1
           FLEXIO_SHIFTCTL_TIMPOL         |        // on falling edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( FLEX_1553RX_PIN_SHFT1_IN )    |        // FLEXIO pin 0
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 1 );              // receive mode

   m_flex->SHIFTCFG[1]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled


   // setup data shifter 2 **************************************************
   // This shifter is configured in receive Mode
   // It captures the fault bits from the state machine decoder
   m_flex->SHIFTCTL[2]  =
           FLEXIO_SHIFTCTL_TIMSEL( 1 )    |        // clocked from timer 1
           FLEXIO_SHIFTCTL_TIMPOL         |        // on falling edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( FLEX_1553RX_PIN_SHFT2_IN )    |        // FLEXIO pin 1
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 1 );              // receive mode

   m_flex->SHIFTCFG[2]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled


   // setup data shifter 3 **************************************************
   // This shifter is configured in Match Continuous Mode
   // It watches for the sync pattern at the start of the 1553 transmission
   // and when found, triggers the data capture
   m_flex->SHIFTCTL[3]  =
           FLEXIO_SHIFTCTL_TIMSEL( 2 )    |        // clocked from timer 2
           // FLEXIO_SHIFTCTL_TIMPOL      |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( m_rxPin )    |        // FLEXIO pin 4    Teensy pin 40  (Input data stream)
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 5 );              // match continuous mode

   m_flex->SHIFTCFG[3]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled

   // The trigger pattern is 1.5 ms of zeros, followed by 1.5 ms of 1's
   // for a total 3 ms pattern @6MHz = 18 bits.
   // We are using 6MHz because this is the fastest that we can sample
   // and still have the pattern fit (almost) in 16 bits. And because
   // 1.5us is a whole number of clocks: 1/6MHz * 9 = 1.5us. This will
   // produce an accurate trigger point.
   // Remove 1 bit to make it even, and to make sure we dont capture
   // anything outside the trigger pattern.
   // pattern = 0000 0001 1111 1111   mask = 0000 0000 0000 0001
   //         = 0x01ff                     = 0x0001
   m_flex->SHIFTBUF[3] =  0x01ff0001U;
   //FLEXIO3_SHIFTBUF3 =  0xffff000fU;
   //FLEXIO3_SHIFTBUF3 =  0x000fffffU;
   //FLEXIO3_SHIFTBUF3 =  0x01fffff0U;



   // State Machine **************************************************
   // This uses five shifters as a five-state state machine to decode the
   // Manchester encoded data
   //  state 0 = fault - no transiton during bit time
   //  state 5 = first  half bit time, with input = 1
   //  state 7 = second half bit time, with input transitioning to 0
   //  state 6 = first  half bit time, with input = 0
   //  state 4 = second half bit time, with input transitioning to 1
   // all 5 shifters are set the same, only the state tables are different

   // setup state 0
   m_flex->SHIFTCTL[0]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( m_rxPin )   |   // input bit used
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

   m_flex->SHIFTCFG[0]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0xF )  |        // disable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs
                                                   //    Teensy pins 19, 18
 // setup state 4
   m_flex->SHIFTCTL[4]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( m_rxPin )   |   // only 1 input bit used              // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

   m_flex->SHIFTCFG[4]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0xF )  |        // disable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs
                                                   //    Teensy pins 2, 3, 4, 33

 // setup state 5
   m_flex->SHIFTCTL[5]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( m_rxPin )   |   // only 1 input bit used              // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

   m_flex->SHIFTCFG[5]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0xF )  |        // disable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs
                                                   //    Teensy pins 2, 3, 4, 33

 // setup state 6
   m_flex->SHIFTCTL[6]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( m_rxPin )   |   // only 1 input bit used              // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

   m_flex->SHIFTCFG[6]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0xF )  |        // disable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs
                                                   //    Teensy pins 2, 3, 4, 33

 // setup state 7
   m_flex->SHIFTCTL[7]  =
           FLEXIO_SHIFTCTL_TIMSEL( 0 )    |        // controlled from timer 0
           FLEXIO_SHIFTCTL_TIMPOL         |        // on negative edge
           FLEXIO_SHIFTCTL_PINCFG( 3 )    |        // enable output
           FLEXIO_SHIFTCTL_PINSEL( m_rxPin )   |   // only 1 input bit used              // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 6 );              // state mode

   m_flex->SHIFTCFG[7]  =
           FLEXIO_SHIFTCFG_PWIDTH( 0xF )  |        // disable FXIO_D[7:4] outputs
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP(  3 )    |        // disable FXIO_D[3:2] outputs
           FLEXIO_SHIFTCFG_SSTART( 0 );            // enable FXIO_D[1:0] outputs
                                                   //    Teensy pins 2, 3, 4, 33
   // Two output bits from the state machine, FXIO_D[1:0], represent data bits
   // (on flex bit 0) and faults (no transition, on flex bit 1). These two bits
   //  will be captured by shifters.

   // load state lookup table               output  : next state
   m_flex->SHIFTBUF[0] =  0x0202E02EU;  //  0000 0010 : 000 000 101 110 000 000 101 110b
   m_flex->SHIFTBUF[5] =  0x001C01C0U;  //  0000 0000 : 000 111 000 000 000 111 000 000b
   m_flex->SHIFTBUF[7] =  0x0102E02EU;  //  0000 0001 : 000 000 101 110 000 000 101 110b
   m_flex->SHIFTBUF[6] =  0x00800800U;  //  0000 0000 : 100 000 000 000 100 000 000 000b
   m_flex->SHIFTBUF[4] =  0x0002E02EU;  //  0000 0000 : 000 000 101 110 000 000 101 110b



   // enable FLEXIO3
   m_flex->CTRL |= 1;    // enable FLEXIO3 module

   return( true );
}


// get status flags for 8 timers and 8 shifters in FlexIO3
// @return  8 timer flags : 8 shifter flags (one byte for each)
unsigned long Flex3_1553RX_get_status( void )
{
  unsigned long flags;

  // make sure Flex clock is enabled
  if( (CCM_CCGR3 & 3) == 0 )
    return( -1 ); // can not read status if Flex clock is disabled

  flags = (FLEXIO3_SHIFTERR << 16) | (FLEXIO3_SHIFTSTAT << 8) | FLEXIO3_TIMSTAT;
  FLEXIO3_SHIFTERR  = 0xff;  // clear flags
  FLEXIO3_SHIFTSTAT = 0xff;
  FLEXIO3_TIMSTAT   = 0xff;
  return( flags );
}



unsigned long Flex3_1553RX_read_data( void )
{
  // make sure Flex clock is enabled
  if( (CCM_CCGR3 & 3) == 0 )
    return( -1 ); // can not read status if Flex clock is disabled

  return( FLEXIO3_SHIFTBUFBIS1 );
}



unsigned long Flex3_1553RX_read_faults( void )
{
  // make sure Flex clock is enabled
  if( (CCM_CCGR3 & 3) == 0 )
    return( -1 ); // can not read status if Flex clock is disabled

  return( FLEXIO3_SHIFTBUFBIS2 );
}




// set trigger pattern for RX data capture. For debug only
int Flex1553RX_trigger( unsigned int trigger, unsigned int pattern )
{
   // the lower 16 bits are the mask bits, which for now are all zero
   FLEXIO3_SHIFTBUF3 = ((unsigned long)trigger << 16) | (unsigned long)pattern;
   return( 0 );
}






// ********************************************************
// This is for testing the "Match Continuous Mode"
// Use a square <40kHz wave as input
int Flex1_1553Sync_config1(void)
{
  // setup flex clock
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_OFF);      // disable clock
  CCM_CDCDR &= ~( CCM_CDCDR_FLEXIO1_CLK_PODF( 7 ) ); // clear flex clock bits
  CCM_CDCDR |= CCM_CDCDR_FLEXIO1_CLK_PODF( 5 );     // set flex clock = 40MHz
                                                    // clock speed = 480MHz/2/(N+1)
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_ON);      // enable clock

  // if the Flex module gets hung up, reconfiguring will not fix it, you will
  // need to reset it. Flex module should be disabled during configuration or
  // else you will likely get "random" output transitions during config.
  // Reset and disable FLEXIO3 (clock MUST be enabled or this will hang)
  FLEXIO1_CTRL |= 2;    // reset Flex module
  FLEXIO1_CTRL &= 0xfffffffc;  // release reset and leave Flex disabled

  // route IO pins to FlexIO 1
    // 1553 input bit stream
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04 = 9;      // FLEXIO pin4    Teensy pin 40
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04 = 4;     // FLEXIO pin4    Teensy pin 2
    // Timer 0,1,2 outputs
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11 = 9;      // FLEXIO pin11   Teensy pin 21
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06 = 4;     // FLEXIO pin6    Teensy pin 4
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05 = 4;     // FLEXIO pin6    Teensy pin 3
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 9;      // FLEXIO pin8    Teensy pin 22
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08 = 4;     // FLEXIO pin8    Teensy pin 5
    // Compare output
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 9;      // FLEXIO pin9    Teensy pin 23
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07 = 4;     // FLEXIO pin7    Teensy pin 33
    // State machine out / shifter in
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12 = 9;      // FLEXIO pin12   Teensy pin 38
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13 = 9;      // FLEXIO pin13   Teensy pin 39


  // setup flex timer 1 *****************************************************
  // this is a 1MHz clock to step both shifters
  // it is clocked from from the FLEXIO clock
  // it is enabled by TBD
  FLEXIO1_TIMCTL1    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |       // Try Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 6 )     |        // timer pin 6 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

  FLEXIO1_TIMCFG1    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // enable timer on trigger rising
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  TBD
  //  22 shifts,  divide clock by 40     ((n*2-1)<<8) | (baudrate_divider/2-1))
  //                                     (22*2-1)<<8  | (40/2-1)
  //                                         (43)<<8  | (19)
  //                                          0x2b00  | 0x13
  FLEXIO1_TIMCMP1    =    0x2b13;


  // setup flex timer 2 *****************************************************
  // this is a 5MHz clock for shifter 3
  // it is clocked from from the FLEXIO clock
  // it is always enabled
  FLEXIO1_TIMCTL2    =
           FLEXIO_TIMCTL_TRGSEL( 0 )      |        // trigger not used
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger not used
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 8 )      |        // timer pin 8 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG2    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  Flex clock = 40MHz, we want 5MHz, so divide by 8
  //  TIMCMP = divider/2-1 = 8/2-1 = 3
  //FLEXIO1_TIMCMP2    =    0x00020003U;
  FLEXIO1_TIMCMP2    =    0x0003U;


  // setup flex timer 3 *****************************************************
  // this is a strange configuration as an experiment
  // it is clocked from from Timer2
  // it is also enabled from Timer2 clock
  FLEXIO1_TIMCTL3    =
           FLEXIO_TIMCTL_TRGSEL( 11 )      |       // trigger on Timer2 out (2 * 4)+3
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 5 )      |        // timer pin 5 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG3    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trig, shift clock = Trig
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // timer disabled on timeout
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // timer enabled on Trig rising edge
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  FLEXIO1_TIMCMP3    =    48;


  // setup flex timer 7 *****************************************************
  // for debug only
  // this just passes the trigger thru to an IO pin for debug
  // it is always enabled
  FLEXIO1_TIMCTL7    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |        // Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGSEL( 11 )     |        // Timer 2 trigger output =(2 * 4) + 3
           //FLEXIO_TIMCTL_TRGSEL( 8 )      |        // Input Pin 4 =(2 * 4) + 0
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 7 )      |        // timer pin 9 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG7    =
           FLEXIO_TIMCFG_TIMOUT( 1 )      |        // timer output = logic low when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trigger input (both edges), Shift clock equals Trigger input.
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


  // setup data shifter 3 **************************************************
  // This shifter is configured in Match Continuous Mode
  // It watches for the sync pattern at the start of the 1553 transmission
  // and when found, triggers the data capture
  FLEXIO1_SHIFTCTL3  =
           FLEXIO_SHIFTCTL_TIMSEL( 3 )    |        // clocked from timer 3
           FLEXIO_SHIFTCTL_TIMPOL      |        // shift on neg edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( 4 )    |        // FLEXIO pin 4    Teensy pin 2  (Input data stream)
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           //FLEXIO_SHIFTCTL_SMOD( 4 );              // match and store mode
           FLEXIO_SHIFTCTL_SMOD( 5 );              // match continuous mode

  FLEXIO1_SHIFTCFG3  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled

  // The trigger pattern is 1.5 ms of zeros, followed by 1.5 ms of 1's
  // for a total 3 ms pattern @5MHz = 15 bits.
  // We are using 5MHz because this is the fastest that we can sample
  // and still have the pattern fit in 16 bits.
  // Remove 1 bit to make it even, and to make sure we dont capture
  // anything outside the trigger pattern.
  // pattern = 0000 0001 1111 11xx   mask = 0000 0000 0000 0011
  //         = 0x01ff                     = 0x0003
  //FLEXIO1_SHIFTBUF3 =  0x01ff0003U;
  FLEXIO1_SHIFTBUF3 =  0x00ff0000U;
  //FLEXIO1_SHIFTBUF3 =  0xff000000U;
  //FLEXIO1_SHIFTBUF3 =  0x01ff0000U;
  //FLEXIO1_SHIFTBUF3 =  0x00000000U;


  // setup data shifter 4 **************************************************
  //Not used
  // This is an experiment to see if it can fix Match Continuous Mode
  // Shifter3 will get its input from here, instead of dirctly from the pin
  FLEXIO1_SHIFTCTL4  =
           FLEXIO_SHIFTCTL_TIMSEL( 2 )    |        // clocked from timer 2
           //FLEXIO_SHIFTCTL_TIMPOL      |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( 4 )    |        // FLEXIO pin 4    Teensy pin 40  (Input data stream)
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 1 );              // receive mode

  FLEXIO1_SHIFTCFG4  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled


  // enable FLEXIO3
  FLEXIO1_CTRL |= 1;    // enable FLEXIO3 module

  return( 0 );
}


// ********************************************************
// This is for testing the "Match Continuous Mode"
// Use a square <40kHz wave as input
// this is pretty much the same as config1, except that Timer3 never disables
int Flex1_1553Sync_config2(void)
{
  // setup flex clock
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_OFF);      // disable clock
  CCM_CDCDR &= ~( CCM_CDCDR_FLEXIO1_CLK_PODF( 7 ) ); // clear flex clock bits
  CCM_CDCDR |= CCM_CDCDR_FLEXIO1_CLK_PODF( 5 );     // set flex clock = 40MHz
                                                    // clock speed = 480MHz/2/(N+1)
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_ON);      // enable clock

  // if the Flex module gets hung up, reconfiguring will not fix it, you will
  // need to reset it. Flex module should be disabled during configuration or
  // else you will likely get "random" output transitions during config.
  // Reset and disable FLEXIO3 (clock MUST be enabled or this will hang)
  FLEXIO1_CTRL |= 2;    // reset Flex module
  FLEXIO1_CTRL &= 0xfffffffc;  // release reset and leave Flex disabled

  // route IO pins to FlexIO 1
    // 1553 input bit stream
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04 = 9;      // FLEXIO pin4    Teensy pin 40
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04 = 4;     // FLEXIO pin4    Teensy pin 2
    // Timer 0,1,2 outputs
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11 = 9;      // FLEXIO pin11   Teensy pin 21
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06 = 4;     // FLEXIO pin6    Teensy pin 4
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05 = 4;     // FLEXIO pin6    Teensy pin 3
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 9;      // FLEXIO pin8    Teensy pin 22
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08 = 4;     // FLEXIO pin8    Teensy pin 5
    // Compare output
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 9;      // FLEXIO pin9    Teensy pin 23
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07 = 4;     // FLEXIO pin7    Teensy pin 33
    // State machine out / shifter in
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12 = 9;      // FLEXIO pin12   Teensy pin 38
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13 = 9;      // FLEXIO pin13   Teensy pin 39


  // setup flex timer 1 *****************************************************
  // this is here so that we can see something happen if we get a trigger from Shifter3
  // produces a 1MHz clock
  // it is clocked from from the FLEXIO clock
  // it is enabled by an output from Shifter3 status flag
  FLEXIO1_TIMCTL1    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |       // Try Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 6 )     |        // timer pin 6 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

  FLEXIO1_TIMCFG1    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // enable timer on trigger rising
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  TBD
  //  22 shifts,  divide clock by 40     ((n*2-1)<<8) | (baudrate_divider/2-1))
  //                                     (22*2-1)<<8  | (40/2-1)
  //                                         (43)<<8  | (19)
  //                                          0x2b00  | 0x13
  FLEXIO1_TIMCMP1    =    0x2b13;


  // setup flex timer 2 *****************************************************
  // this is a 5MHz clock for shifter 3
  // it is clocked from from the FLEXIO clock
  // it is always enabled
  FLEXIO1_TIMCTL2    =
           FLEXIO_TIMCTL_TRGSEL( 0 )      |        // trigger not used
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger not used
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 8 )      |        // timer pin 8 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG2    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  Flex clock = 40MHz, we want 5MHz, so divide by 8
  //  TIMCMP = divider/2-1 = 8/2-1 = 3
  //FLEXIO1_TIMCMP2    =    0x00020003U;
  FLEXIO1_TIMCMP2    =    0x0003U;


  // setup flex timer 3 *****************************************************
  // this is a strange configuration as an experiment
  // it is clocked from from Timer2
  // it is also enabled from Timer2 clock
  FLEXIO1_TIMCTL3    =
           FLEXIO_TIMCTL_TRGSEL( 11 )      |       // trigger on Timer2 out (2 * 4)+3
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 5 )      |        // timer pin 5 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG3    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trig, shift clock = Trig
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // timer never disables
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // timer enabled on Trig rising edge
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  FLEXIO1_TIMCMP3    =   10000;


  // setup flex timer 7 *****************************************************
  // for debug only
  // this just passes the trigger thru to an IO pin for debug
  // it is always enabled
  FLEXIO1_TIMCTL7    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |        // Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGSEL( 11 )     |        // Timer 2 trigger output =(2 * 4) + 3
           //FLEXIO_TIMCTL_TRGSEL( 8 )      |        // Input Pin 4 =(2 * 4) + 0
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 7 )      |        // timer pin 9 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG7    =
           FLEXIO_TIMCFG_TIMOUT( 1 )      |        // timer output = logic low when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trigger input (both edges), Shift clock equals Trigger input.
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


  // setup data shifter 3 **************************************************
  // This shifter is configured in Match Continuous Mode
  // It watches for the sync pattern at the start of the 1553 transmission
  // and when found, triggers the data capture
  FLEXIO1_SHIFTCTL3  =
           FLEXIO_SHIFTCTL_TIMSEL( 3 )    |        // clocked from timer 3
           FLEXIO_SHIFTCTL_TIMPOL      |        // shift on neg edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( 4 )    |        // FLEXIO pin 4    Teensy pin 2  (Input data stream)
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           //FLEXIO_SHIFTCTL_SMOD( 4 );              // match and store mode
           FLEXIO_SHIFTCTL_SMOD( 5 );              // match continuous mode

  FLEXIO1_SHIFTCFG3  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled

  // The trigger pattern is 1.5 ms of zeros, followed by 1.5 ms of 1's
  // for a total 3 ms pattern @5MHz = 15 bits.
  // We are using 5MHz because this is the fastest that we can sample
  // and still have the pattern fit in 16 bits.
  // Remove 1 bit to make it even, and to make sure we dont capture
  // anything outside the trigger pattern.
  // pattern = 0000 0001 1111 11xx   mask = 0000 0000 0000 0011
  //         = 0x01ff                     = 0x0003
  //FLEXIO1_SHIFTBUF3 =  0x01ff0003U;
  //FLEXIO1_SHIFTBUF3 =  0xffff000fU;
  FLEXIO1_SHIFTBUF3 =  0xff000000U;
  //FLEXIO1_SHIFTBUF3 =  0x01ff0000U;
  //FLEXIO1_SHIFTBUF3 =  0x00000000U;


  // setup data shifter 4 **************************************************
  //Not used
  // This is an experiment to see if it can fix Match Continuous Mode
  // Shifter3 will get its input from here, instead of dirctly from the pin
  FLEXIO1_SHIFTCTL4  =
           FLEXIO_SHIFTCTL_TIMSEL( 2 )    |        // clocked from timer 2
           //FLEXIO_SHIFTCTL_TIMPOL      |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( 4 )    |        // FLEXIO pin 4    Teensy pin 40  (Input data stream)
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 1 );              // receive mode

  FLEXIO1_SHIFTCFG4  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled


  // enable FLEXIO3
  FLEXIO1_CTRL |= 1;    // enable FLEXIO3 module

  return( 0 );
}


// ********************************************************
// This is for testing the "Match Continuous Mode"
// Use a square <40kHz wave as input
// this is pretty much the same as config2, except that Timer2 & 3 are combined into a dual 8-bit timer
int Flex1_1553Sync_config3(void)
{
  // setup flex clock
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_OFF);      // disable clock
  CCM_CDCDR &= ~( CCM_CDCDR_FLEXIO1_CLK_PODF( 7 ) ); // clear flex clock bits
  CCM_CDCDR |= CCM_CDCDR_FLEXIO1_CLK_PODF( 5 );     // set flex clock = 40MHz
                                                    // clock speed = 480MHz/2/(N+1)
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_ON);      // enable clock

  // if the Flex module gets hung up, reconfiguring will not fix it, you will
  // need to reset it. Flex module should be disabled during configuration or
  // else you will likely get "random" output transitions during config.
  // Reset and disable FLEXIO3 (clock MUST be enabled or this will hang)
  FLEXIO1_CTRL |= 2;    // reset Flex module
  FLEXIO1_CTRL &= 0xfffffffc;  // release reset and leave Flex disabled

  // route IO pins to FlexIO 1
    // input bit stream
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04 = 4;     // FLEXIO pin4    Teensy pin 2
    // Timer 0,1,2 outputs
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05 = 4;     // FLEXIO pin5    Teensy pin 3
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06 = 4;     // Timer1  FLEXIO pin6    Teensy pin 4
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07 = 4;     // Timer7  FLEXIO pin7    Teensy pin 33
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08 = 4;     // Timer2  FLEXIO pin8    Teensy pin 5


  // setup flex timer 1 *****************************************************
  // this is here so that we can see something happen if we get a trigger from Shifter3
  // produces a 1MHz clock
  // it is clocked from from the FLEXIO clock
  // it is enabled by an output from Shifter3 status flag
  FLEXIO1_TIMCTL1    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |       // Try Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 6 )     |        // timer pin 6 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

  FLEXIO1_TIMCFG1    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // enable timer on trigger rising
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  TBD
  //  22 shifts,  divide clock by 40     ((n*2-1)<<8) | (baudrate_divider/2-1))
  //                                     (22*2-1)<<8  | (40/2-1)
  //                                         (43)<<8  | (19)
  //                                          0x2b00  | 0x13
  FLEXIO1_TIMCMP1    =    0x2b13;


  // setup flex timer 2 *****************************************************
  // this is a 5MHz clock for shifter 3
  // it is clocked from from the FLEXIO clock
  // it is always enabled
  FLEXIO1_TIMCTL2    =
           FLEXIO_TIMCTL_TRGSEL( 0 )      |        // trigger not used
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger not used
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 8 )      |        // timer pin 8 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // 8-bit counter/baud mode

  FLEXIO1_TIMCFG2    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  Flex clock = 40MHz, we want 5MHz, so divide by 8
  //  50 shifts,  divide clock by 8      ((n*2-1)<<8) | (baudrate_divider/2-1))
  //                                     (50*2-1)<<8  | (8/2-1)
  //                                         (99)<<8  | (3)
  //                                          0x6300  | 0x03
  FLEXIO1_TIMCMP2    =    0x6303U;


  // setup flex timer 7 *****************************************************
  // for debug only
  // this just passes the trigger thru to an IO pin for debug
  // it is always enabled
  FLEXIO1_TIMCTL7    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |        // Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGSEL( 11 )     |        // Timer 2 trigger output =(2 * 4) + 3
           //FLEXIO_TIMCTL_TRGSEL( 8 )      |        // Input Pin 4 =(2 * 4) + 0
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 7 )      |        // timer pin 9 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG7    =
           FLEXIO_TIMCFG_TIMOUT( 1 )      |        // timer output = logic low when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trigger input (both edges), Shift clock equals Trigger input.
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


  // setup data shifter 3 **************************************************
  // This shifter is configured in Match Continuous Mode
  // It watches for the sync pattern at the start of the 1553 transmission
  // and when found, triggers the data capture
  FLEXIO1_SHIFTCTL3  =
           FLEXIO_SHIFTCTL_TIMSEL( 2 )    |        // clocked from timer 2
           FLEXIO_SHIFTCTL_TIMPOL      |        // shift on neg edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( 4 )    |        // FLEXIO pin 4    Teensy pin 2  (Input data stream)
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           //FLEXIO_SHIFTCTL_SMOD( 4 );              // match and store mode
           FLEXIO_SHIFTCTL_SMOD( 5 );              // match continuous mode

  FLEXIO1_SHIFTCFG3  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled

  // The trigger pattern is 1.5 ms of zeros, followed by 1.5 ms of 1's
  // for a total 3 ms pattern @5MHz = 15 bits.
  // We are using 5MHz because this is the fastest that we can sample
  // and still have the pattern fit in 16 bits.
  // Remove 1 bit to make it even, and to make sure we dont capture
  // anything outside the trigger pattern.
  // pattern = 0000 0001 1111 11xx   mask = 0000 0000 0000 0011
  //         = 0x01ff                     = 0x0003
  //FLEXIO1_SHIFTBUF3 =  0x01ff0003U;
  //FLEXIO1_SHIFTBUF3 =  0xffff000fU;
  FLEXIO1_SHIFTBUF3 =  0xff000000U;
  //FLEXIO1_SHIFTBUF3 =  0x01ff0000U;
  //FLEXIO1_SHIFTBUF3 =  0x00000000U;


  // enable FLEXIO3
  FLEXIO1_CTRL |= 1;    // enable FLEXIO3 module

  return( 0 );
}


// ********************************************************
// This is for testing the "Match Continuous Mode"
// Use a square <40kHz wave as input
// this adds another timer (Timer3) to config3, to reset Timer2 before it can timeout
// hopefully this solves the most serious bug
//   This does not work because in 8-bit mode, reset only resets the Baud count,
//   not the shift count, which is the one we care about.
int Flex1_1553Sync_config4(void)
{
  // setup flex clock
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_OFF);      // disable clock
  CCM_CDCDR &= ~( CCM_CDCDR_FLEXIO1_CLK_PODF( 7 ) ); // clear flex clock bits
  CCM_CDCDR |= CCM_CDCDR_FLEXIO1_CLK_PODF( 5 );     // set flex clock = 40MHz
                                                    // clock speed = 480MHz/2/(N+1)
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_ON);      // enable clock

  // if the Flex module gets hung up, reconfiguring will not fix it, you will
  // need to reset it. Flex module should be disabled during configuration or
  // else you will likely get "random" output transitions during config.
  // Reset and disable FLEXIO3 (clock MUST be enabled or this will hang)
  FLEXIO1_CTRL |= 2;    // reset Flex module
  FLEXIO1_CTRL &= 0xfffffffc;  // release reset and leave Flex disabled

  // route IO pins to FlexIO 1
    // 1553 input bit stream
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04 = 9;      // FLEXIO pin4    Teensy pin 40
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04 = 4;     // FLEXIO pin4    Teensy pin 2
    // Timer 0,1,2 outputs
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11 = 9;      // FLEXIO pin11   Teensy pin 21
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06 = 4;     // FLEXIO pin6    Teensy pin 4
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05 = 4;     // FLEXIO pin6    Teensy pin 3
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 9;      // FLEXIO pin8    Teensy pin 22
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08 = 4;     // FLEXIO pin8    Teensy pin 5
    // Compare output
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 9;      // FLEXIO pin9    Teensy pin 23
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07 = 4;     // FLEXIO pin7    Teensy pin 33
    // State machine out / shifter in
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12 = 9;      // FLEXIO pin12   Teensy pin 38
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13 = 9;      // FLEXIO pin13   Teensy pin 39


  // setup flex timer 1 *****************************************************
  // this is here so that we can see something happen if we get a trigger from Shifter3
  // produces a 1MHz clock
  // it is clocked from from the FLEXIO clock
  // it is enabled by an output from Shifter3 status flag
  FLEXIO1_TIMCTL1    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |       //  Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 6 )     |        // timer pin 6 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

  FLEXIO1_TIMCFG1    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // enable timer on trigger rising
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  TBD
  //  22 shifts,  divide clock by 40     ((n*2-1)<<8) | (baudrate_divider/2-1))
  //                                     (22*2-1)<<8  | (40/2-1)
  //                                         (43)<<8  | (19)
  //                                          0x2b00  | 0x13
  FLEXIO1_TIMCMP1    =    0x2b13;


  // setup flex timer 2 *****************************************************
  // this is a 5MHz clock for shifter 3
  // it is clocked from from the FLEXIO clock
  // it is always enabled
  FLEXIO1_TIMCTL2    =
           FLEXIO_TIMCTL_TRGSEL( 10 )     |        // Timer3 out =(3 * 4) + 3
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 8 )      |        // timer pin 8 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // 8-bit counter/baud mode

  FLEXIO1_TIMCFG2    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 7 )      |        // reset count on trigger, both edges edge
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  Flex clock = 40MHz, we want 5MHz, so divide by 8
  //  51 shifts,  divide clock by 8      ((n*2-1)<<8) | (baudrate_divider/2-1))
  //                                     (51*2-1)<<8  | (8/2-1)
  //                                        (101)<<8  | (3)
  //                                          0x6500  | 0x03
  FLEXIO1_TIMCMP2    =    0x6503U;


  // setup flex timer 3 *****************************************************
  // this is an an extra timer that produces a reset to Timer2
  // it is clocked from from FlexIO
  // it is always enabled
  FLEXIO1_TIMCTL3    =
           FLEXIO_TIMCTL_TRGSEL( 0 )      |        // trigger not used
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger not used
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 5 )      |        // timer pin 5 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit counter mode

  FLEXIO1_TIMCFG3    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled

  //  50 shifts * 8 flex clocks             (n-1)
  //                                      (400-1)
  //                                        (399)
  //                                       0x018F
  FLEXIO1_TIMCMP3    =  0x18F;


  // setup flex timer 7 *****************************************************
  // for debug only
  // this just passes the trigger thru to an IO pin for debug
  // it is always enabled
  FLEXIO1_TIMCTL7    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |        // Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGSEL( 11 )     |        // Timer 2 trigger output =(2 * 4) + 3
           //FLEXIO_TIMCTL_TRGSEL( 8 )      |        // Input Pin 4 =(2 * 4) + 0
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 7 )      |        // timer pin 9 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG7    =
           FLEXIO_TIMCFG_TIMOUT( 1 )      |        // timer output = logic low when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trigger input (both edges), Shift clock equals Trigger input.
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


  // setup data shifter 3 **************************************************
  // This shifter is configured in Match Continuous Mode
  // It watches for the sync pattern at the start of the 1553 transmission
  // and when found, triggers the data capture
  FLEXIO1_SHIFTCTL3  =
           FLEXIO_SHIFTCTL_TIMSEL( 2 )    |        // clocked from timer 2
           FLEXIO_SHIFTCTL_TIMPOL      |        // shift on neg edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( 4 )    |        // FLEXIO pin 4    Teensy pin 2  (Input data stream)
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           //FLEXIO_SHIFTCTL_SMOD( 4 );              // match and store mode
           FLEXIO_SHIFTCTL_SMOD( 5 );              // match continuous mode

  FLEXIO1_SHIFTCFG3  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled

  // The trigger pattern is 1.5 ms of zeros, followed by 1.5 ms of 1's
  // for a total 3 ms pattern @5MHz = 15 bits.
  // We are using 5MHz because this is the fastest that we can sample
  // and still have the pattern fit in 16 bits.
  // Remove 1 bit to make it even, and to make sure we dont capture
  // anything outside the trigger pattern.
  // pattern = 0000 0001 1111 11xx   mask = 0000 0000 0000 0011
  //         = 0x01ff                     = 0x0003
  //FLEXIO1_SHIFTBUF3 =  0x01ff0003U;
  //FLEXIO1_SHIFTBUF3 =  0xffff000fU;
  FLEXIO1_SHIFTBUF3 =  0xff000000U;
  //FLEXIO1_SHIFTBUF3 =  0x01ff0000U;
  //FLEXIO1_SHIFTBUF3 =  0x00000000U;


  // enable FLEXIO3
  FLEXIO1_CTRL |= 1;    // enable FLEXIO3 module

  return( 0 );
}



// ********************************************************
// This is for testing the "Match Continuous Mode"
// Use a square <30kHz wave as input
// this adds another timer (Timer4) to config2, to reset Timer2 before it can timeout
// this should be the same as Config4, but using 16-bit counters
// this appears to work!!
// timers are not in any logical order, this is just how it was configured when I got it to work
int Flex1_1553Sync_config5(void)
{
  // setup flex clock for i.MXRT1062
  // note that the clock setup is device specific
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_OFF);      // disable clock
  CCM_CDCDR &= ~( CCM_CDCDR_FLEXIO1_CLK_PODF( 7 ) ); // clear flex clock bits
  CCM_CDCDR |= CCM_CDCDR_FLEXIO1_CLK_PODF( 5 );     // set flex clock = 40MHz
                                                    // clock speed = 480MHz/2/(N+1)
  CCM_CCGR5 |= CCM_CCGR5_FLEXIO1(CCM_CCGR_ON);      // enable clock

  // if the Flex module gets hung up, reconfiguring will not fix it, you will
  // need to reset it. Flex module should be disabled during configuration or
  // else you will likely get "random" output transitions during config.
  // Reset and disable FLEXIO1 (clock MUST be enabled or this will hang)
  FLEXIO1_CTRL |= 2;    // reset Flex module
  FLEXIO1_CTRL &= 0xfffffffc;  // release reset and leave Flex disabled

  // route IO pins to FlexIO 1
    // input bit stream
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_04 = 4;     // FLEXIO pin4    Teensy pin 2
    // Timer 0,1,2 outputs
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_05 = 4;     // FLEXIO pin5    Teensy pin 3
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_06 = 4;     // FLEXIO pin6    Teensy pin 4
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_07 = 4;     // FLEXIO pin7    Teensy pin 33
  IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_08 = 4;     // FLEXIO pin8    Teensy pin 5

  #define SHIFTER3_IN   4     // Teensy pin 2    match input
  #define TIMER1_OUT    6     // Teensy pin 4    for debug only
  #define TIMER2_OUT    8     // Teensy pin 5    for debug only
  #define TIMER4_OUT    5     // Teensy pin 3    reset for Timer3
  #define TIMER7_OUT    7     // Teensy pin 33   for debug only


  // setup flex timer 1 *****************************************************
  // this is here so that we can see something happen if we get a trigger from Shifter3
  // produces a 1MHz clock
  // it is clocked from from the FLEXIO clock
  // it is enabled by an output from Shifter3 status flag
  FLEXIO1_TIMCTL1    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |        // Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL(TIMER1_OUT) |      // timer pin 6 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

  FLEXIO1_TIMCFG1    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // enable timer on trigger rising
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  TBD
  //  22 shifts,  divide clock by 40     ((n*2-1)<<8) | (baudrate_divider/2-1))
  //                                     (22*2-1)<<8  | (40/2-1)
  //                                         (43)<<8  | (19)
  //                                          0x2b00  | 0x13
  FLEXIO1_TIMCMP1    =    0x2b13;


  // setup flex timer 2 *****************************************************
  // this is a 5MHz shift clock for shifter 3
  // it is clocked from from the FLEXIO clock
  // it is always enabled
  FLEXIO1_TIMCTL2    =
           FLEXIO_TIMCTL_TRGSEL( 0 )      |        // trigger not used
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger not used
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL(TIMER2_OUT) |      // timer pin 8 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG2    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  Flex clock = 40MHz, we want 5MHz, so divide by 8
  //  TIMCMP = divider/2-1 = 8/2-1 = 3
  FLEXIO1_TIMCMP2    =    0x0003U;


  // setup flex timer 3 *****************************************************
  // this is the shift counter for Shifter3
  // the shift clock is passed thru from Timer2
  // it is clocked from from Timer2
  // it is always enabled
  // it is reset by Timer4
  FLEXIO1_TIMCTL3    =
           FLEXIO_TIMCTL_TRGSEL( 11 )     |        // trigger on Timer2 out (2 * 4)+3
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 0 )      |        // timer pin output disabled
           FLEXIO_TIMCTL_PINSEL(TIMER4_OUT) |      // timer pin 5 (used as Reset input)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG3    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trig, shift clock = Trig
           FLEXIO_TIMCFG_TIMRST( 4 )      |        // reset timer on pin rising edge
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // timer never disables
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


  //  102 shifts                           (n*2-1)
  //                                     (102*2-1)
  //                                         (204)
  FLEXIO1_TIMCMP3    =    203;
  // this would normally timeout and stop after 102 shifts, however it will be reset by Timer4
  // after 100 shifts, so the timeout never happens


  // setup flex timer 4 *****************************************************
  // this is an an extra timer that produces a reset to Timer3
  // it is clocked from from FlexIO
  // it is always enabled
  FLEXIO1_TIMCTL4    =
           FLEXIO_TIMCTL_TRGSEL( 0 )      |        // trigger not used
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger not used
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL(TIMER4_OUT) |      // timer pin 5 (resets Timer3)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit counter mode

  FLEXIO1_TIMCFG4    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled

  //  50 shifts * 8 flex clocks             (n-1)
  //                                      (400-1)
  //                                        (399)
  //                                       0x018F
  FLEXIO1_TIMCMP4    =  0x18F;
  // output toggles after 50 shifts, but reset is on rising edge only, so reset is every 100 shifts


  // setup flex timer 7 *****************************************************
  // for debug only
  // this basically passes the trigger thru to an IO pin for debug
  // it is always enabled
  FLEXIO1_TIMCTL7    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |        // Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL(TIMER7_OUT) |      // timer pin 7 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO1_TIMCFG7    =
           FLEXIO_TIMCFG_TIMOUT( 1 )      |        // timer output = logic low when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trigger input (both edges), Shift clock equals Trigger input.
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  FLEXIO1_TIMCMP7    =  0;    // times out on first clock after trigger


  // setup data shifter 3 **************************************************
  // This shifter is configured in Match Continuous Mode
  // It watches for the sync pattern at the start of the 1553 transmission
  // and when found, triggers the data capture
  FLEXIO1_SHIFTCTL3  =
           FLEXIO_SHIFTCTL_TIMSEL( 3 )    |        // clocked from timer 3
           FLEXIO_SHIFTCTL_TIMPOL         |        // shift on neg edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL(SHIFTER3_IN) |   // FLEXIO pin 4    Teensy pin 2  (Input data stream)
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 5 );              // match continuous mode

  FLEXIO1_SHIFTCFG3  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled

  FLEXIO1_SHIFTBUF3 =  0xff000000U;    // pattern triggers on a glitch free rising edge
  //FLEXIO1_SHIFTBUF3 =  0x00ff0000U;    // pattern triggers on a glitch free falling edge



  // enable FLEXIO3
  FLEXIO1_CTRL |= 1;    // enable FLEXIO3 module

  return( 0 );
}




int Flex1_writeShifter3( unsigned long config )
{
   FLEXIO1_SHIFTBUF3 = config;
   return 0;
}


uint32_t Flex1_readShifter3( void )
{
   return FLEXIO1_SHIFTBUF3;
}



// ********************************************************
// This is for testing the "Match Continuous Mode"
// Use a square <40kHz wave as input
// processor = I.MXRT1062
int Flex3_1553Sync_config(void)
{
  // setup flex clock
  // note: FlexIO2 and FlexIO3 share the same clock
  CCM_CS1CDR &= ~( CCM_CS1CDR_FLEXIO2_CLK_PODF( 7 ) ); // clear flex clock bits
  CCM_CS1CDR |= CCM_CS1CDR_FLEXIO2_CLK_PODF( 4 );   // set flex clock = 48MHz
                                                    // clock speed = 480MHz/(N+1)
  CCM_CCGR3 |= CCM_CCGR3_FLEXIO2(CCM_CCGR_ON);      // enable clock

  // if the Flex module gets hung up, reconfiguring will not fix it, you will
  // need to reset it. Flex module should be disabled during configuration or
  // else you will likely get "random" output transitions during config.
  // Reset and disable FLEXIO3 (clock MUST be enabled or this will hang)
  FLEXIO3_CTRL |= 2;    // reset Flex module
  FLEXIO3_CTRL &= 0xfffffffc;  // release reset and leave Flex disabled

  // route IO pins to FlexIO 3
    // 1553 input bit stream
  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_04 = 9;      // FLEXIO pin4    Teensy pin 40
    // Timer 0,1,2 outputs
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_10 = 9;      // FLEXIO pin10   Teensy pin 20
  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_11 = 9;      // FLEXIO pin11   Teensy pin 21
  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_08 = 9;      // FLEXIO pin8    Teensy pin 22
    // Compare output
  IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_09 = 9;      // FLEXIO pin9    Teensy pin 23
    // State machine out / shifter in
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_12 = 9;      // FLEXIO pin12   Teensy pin 38
  //IOMUXC_SW_MUX_CTL_PAD_GPIO_AD_B1_13 = 9;      // FLEXIO pin13   Teensy pin 39


  // setup flex timer 1 *****************************************************
  // this is a 1MHz clock to step both shifters
  // it is clocked from from the FLEXIO clock
  // it is enabled by TBD
  FLEXIO3_TIMCTL1    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |       // Try Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 11 )     |        // timer pin 11 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // dual counter/baud mode

  FLEXIO3_TIMCFG1    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 2 )      |        // disable timer on timer compare
           FLEXIO_TIMCFG_TIMENA( 6 )      |        // enable timer on trigger rising
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  TBD
  //  22 shifts,  divide clock by 40     ((n*2-1)<<8) | (baudrate_divider/2-1))
  //                                     (22*2-1)<<8  | (40/2-1)
  //                                         (43)<<8  | (19)
  //                                          0x2b00  | 0x13
  FLEXIO3_TIMCMP1    =    0x2b13;


  // setup flex timer 2 *****************************************************
  // this is a 6MHz clock for shifter 3
  // it is clocked from from the FLEXIO clock
  // it is always enabled
  FLEXIO3_TIMCTL2    =
           FLEXIO_TIMCTL_TRGSEL( 0 )      |        // trigger not used
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger not used
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 8 )      |        // timer pin 8 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 1 );               // 16-bit timer mode

  FLEXIO3_TIMCFG2    =
           FLEXIO_TIMCFG_TIMOUT( 0 )      |        // timer output = logic high when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 0 )      |        // decrement on FlexIO clock, shift clock = timer output
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled

  //  Flex clock = 48MHz, we want 6MHz, so divide by 8
  //  TIMCMP = divider/2-1 = 8/2-1 = 3
  //FLEXIO3_TIMCMP2    =    0xffff0003U;
  FLEXIO3_TIMCMP2    =    0x0003U;


  // setup flex timer 7 *****************************************************
  // for debug only
  // this just passes the trigger thru to an IO pin for debug
  // it is always enabled
  FLEXIO3_TIMCTL7    =
           FLEXIO_TIMCTL_TRGSEL( 13 )     |        // Shifter3 status flag =(3 * 4) + 1
           //FLEXIO_TIMCTL_TRGSEL( 11 )     |        // Timer 2 trigger output =(2 * 4) + 3
           //FLEXIO_TIMCTL_TRGSEL( 8 )      |        // Input Pin 4 =(2 * 4) + 0
           //FLEXIO_TIMCTL_TRGPOL         |        // trigger active high
           FLEXIO_TIMCTL_TRGSRC           |        // internal trigger
           FLEXIO_TIMCTL_PINCFG( 3 )      |        // timer pin output enabled
           FLEXIO_TIMCTL_PINSEL( 9 )      |        // timer pin 9 (for debug only)
           // FLEXIO_TIMCTL_PINPOL        |        // timer pin active high
           FLEXIO_TIMCTL_TIMOD( 3 );               // 16-bit timer mode

  FLEXIO3_TIMCFG7    =
           FLEXIO_TIMCFG_TIMOUT( 1 )      |        // timer output = logic low when enabled, not affcted by reset
           FLEXIO_TIMCFG_TIMDEC( 3 )      |        // decrement on Trigger input (both edges), Shift clock equals Trigger input.
           FLEXIO_TIMCFG_TIMRST( 0 )      |        // dont reset timer
           FLEXIO_TIMCFG_TIMDIS( 0 )      |        // never disable
           FLEXIO_TIMCFG_TIMENA( 0 )      |        // timer is always enabled
           FLEXIO_TIMCFG_TSTOP(  0 )    ;          // stop bit disabled
           // FLEXIO_TIMCFG_TSTART                 // start bit disabled


  // setup data shifter 3 **************************************************
  // This shifter is configured in Match Continuous Mode
  // It watches for the sync pattern at the start of the 1553 transmission
  // and when found, triggers the data capture
  FLEXIO3_SHIFTCTL3  =
           FLEXIO_SHIFTCTL_TIMSEL( 2 )    |        // clocked from timer 2
           // FLEXIO_SHIFTCTL_TIMPOL      |        // on positive edge
           FLEXIO_SHIFTCTL_PINCFG( 0 )    |        // pin output disabled
           FLEXIO_SHIFTCTL_PINSEL( 4 )    |        // FLEXIO pin 4    Teensy pin 40  (Input data stream)
           // FLEXIO_SHIFTCTL_PINPOL      |        // active high
           FLEXIO_SHIFTCTL_SMOD( 5 );              // match continuous mode

  FLEXIO3_SHIFTCFG3  =
           FLEXIO_SHIFTCFG_PWIDTH( 0 )    |        // single bit width
           // FLEXIO_SHIFTCFG_INSRC       |        // from pin
           FLEXIO_SHIFTCFG_SSTOP( 0 )     |        // stop bit disabled
           FLEXIO_SHIFTCFG_SSTART( 0 );            // start bit disabled

  // pattern = 0000 0001 1111 11xx   mask = 0000 0000 0000 0011
  //         = 0x01ff                     = 0x0003
  //FLEXIO3_SHIFTBUF3 =  0x01ff0003U;
  //FLEXIO3_SHIFTBUF3 =  0xffff000fU;
  FLEXIO3_SHIFTBUF3 =  0x0000000fU;
  //FLEXIO3_SHIFTBUF3 =  0x01fffff0U;


  // enable FLEXIO3
  FLEXIO3_CTRL |= 1;    // enable FLEXIO3 module

  return( 0 );
}


